
Features
--------

Powerful new classes
~~~~~~~~~~~~~~~~~~~~
	- B{Node classes} for nearly every major DAG object
	- An B{Attribute class} organizes all the attribute commands in one place
	- Slice and dice your B{file paths} with ease
	- Operate on B{sets} as if they were python's builtin set type
	- Perform B{vector math}, convert between spaces, and easily set object attributes with the results 

Do More with Less Code
~~~~~~~~~~~~~~~~~~~~~~
	- B{Customized operators} for succinct scripting
	- Call Mel procedures as if they were python commands: B{no more annoying string formatting}
	- Manage B{optionVars as a python dictionary}
	- Enhanced Commands with B{intelligent defaults and new flags}
	- B{Automatic Casting to Pymel Types}: values are returned as pymel Nodes, Paths, Vectors, etc.

Its Just Better
~~~~~~~~~~~~~~~
	- B{Fixes Bugs in maya.cmds}: with pymel, maya's bugs are corrected behind the scenes so you don't even know they exist!
	- Use python's help() command on nearly any object to get meaningful help docs.
	
Includes Tools to Ease Your Transition to Python
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	- B{mel-to-python translator} for converting mel script into python scripts
	- B{python-to-mel plugin factory} for turning python classes into mel commands


			
Code Comparision
----------------


MEL
~~~
::
	string $objs[] = `ls -type transform`;
	for ($x in $objs) {
		print (longNameOf($x)); print "\n";	
	
		// make and break some connections
		connectAttr( $x + ".sx") ($x + ".sy");
		connectAttr( $x + ".sx") ($x + ".sz");
		disconnectAttr( $x + ".sx") ($x + ".sy");
		string $conn[] = `listConnections -s 0 -d 1 -p 1 ($x + ".sx")`;
		for ($inputPlug in $conn)
			disconnectAttr ($x + ".sx") $inputPlug;
	
		// add and set a string array attribute
		// with the history of this transform's shape
		if ( !`attributeExists "newAt" $x`)
			addAttr -ln newAt -dataType stringArray $x;
		string $shape[] = `listRelatives -s $x`;
		string $history[] = `listHistory $shape[0]`;
		string $elements = "";
		for ($elem in $history) 
			$elements += "\"" + $elem + "\" ";
		eval ("setAttr -type stringArray " + $x + ".newAt " + `size $history` + $elements);
		print `getAttr ( $x + ".newAt" )`;
	
		// get and set some attributes
		setAttr ($x + ".rotate") 1 1 1;
		float $trans[] = `getAttr ($x + ".translate")`;
		float $scale[] = `getAttr ($x + ".scale")`;
		$trans[0] *= $scale[0];
		$trans[1] *= $scale[1];
		$trans[2] *= $scale[2];
		setAttr ($x + ".scale") $trans[0] $trans[1] $trans[2];	

		// call some other scripts	
		myMelScript( `nodeType $x`, $trans );
	}


Default Python
~~~~~~~~~~~~~~
::
	import maya.cmds as cmds
	import maya.mel as mm
	objs = cmds.ls( type= 'transform') 
	if objs is not None:					# returns None when it finds no matches
		for x in objs:
			print mm.eval('longNameOf("%s")' % x)

			# make and break some connections
			cmds.connectAttr(   '%s.sx' % x,  '%s.sy' % x )
			cmds.connectAttr(   '%s.sx' % x,  '%s.sz' % x )
			cmds.disconnectAttr( '%s.sx' % x,  '%s.sy' % x)

			conn = cmds.listConnections( x + ".sx", s=0, d=1, p=1)
			# returns None when it finds no matches
			if conn is not None:				
				for inputPlug in conn:
					cmds.disconnectAttr( x + ".sx", inputPlug )

			# add and set a string array attribute 
			# with the history of this transform's shape
			if not mm.eval( 'attributeExists "newAt" "%s"' % x): 
				cmds.addAttr(  x, ln='newAt', dataType='stringArray')
			shape = cmds.listRelatives( x, s=1 )
			history = cmds.listHistory( shape[0] )
			args = tuple( ['%s.newAt' % x, len(history)] + history )
			cmds.setAttr( *args ,  **{ 'type' : 'stringArray' } )
			print cmds.getAttr ( x + ".newAt" )

			# get and set some attributes
			cmds.setAttr ( '%s.rotate' % x, 1,  1, 1 )
			scale = cmds.getAttr ( '%s.scale' % x )
			scale = scale[0] # maya packs the previous result in a list for no apparent reason
			trans = list( cmds.getAttr ( '%s.translate' % x )[0] )  # the tuple must be converted to a list for item assignment
			trans[0] *= scale[0]
			trans[1] *= scale[1]
			trans[2] *= scale[2]
			cmds.setAttr ( '%s.scale' % x, trans[0], trans[1], trans[2] )
			mm.eval('myMelScript("%s",{%s,%s,%s})' % (cmds.nodeType(x), trans[0], trans[1], trans[2]) )


With Pymel
~~~~~~~~~~
::
	from pymel import *                   # safe to import into main namespace
	for x in ls( type='transform'):
		print x.longName()                # object oriented design

		# make and break some connections
		x.sx >> x.sy                      # connection operator	
		x.sx >> x.sz	
		x.sx <> x.sy                      # disconnection operator
		x.sx.disconnect()                 # smarter methods -- (automatically disconnects all inputs and outputs when no arg is passed)

		# add and set a string array attribute
		# with the history of this transform's shape
		if not x.newAt.exists():
			x.newAt.add( dataType='stringArray')
		x.newAt = x.getShape().history()

		# get and set some attributes
		x.rotate =  [1,1,1]	
		trans = x._translate.get()
		trans *= x.scale.get()           # vector math
		x._translate = trans              # ability to pass list/vector args
		mel.myMelScript( x.type(), trans) # automatic handling of mel commands


As you can see, pymel has a lot of little touches that make writing python code in maya a lot simpler -- as
it should be.  pymel handles automatic casting of arguments and return values as much as it can, so that
you don't have to.  for example, the 'get' method returns a simple vector type when returning triples from
transforms so you can perform vector math on the fly.  also, you can set triple values directly as a list, 
instead of having to unpack it (see the scale setAttr example above). Another nice feature is that pymel 
commands that return lists (such as ls and listRelatives) return empty lists instead of nothing when they 
find no match.  that is why, in the above examples, the default python example must first place the 'ls'
results in a variable and check if it is 'None', whereas the pymel example will simply not enter the for loop
if there are no transforms in the scene. 
