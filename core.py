"""
The core module contains all of the functions which do not fall under the category of `ui`, `node`, or `ctx`.
"""


import sys, os, re
from getpass import getuser
from socket import gethostname

try:
	import maya.cmds as cmds
	import maya.mel as mm
	import maya.OpenMaya as OpenMaya

except ImportError:
	pass

import util, factories, node, ui
from vector import *

try:
	from luma.filepath import filepath as Filepath
	pathClass = Filepath
except ImportError:
	import path
	pathClass = path.path

"controls whether functions that return dag nodes use the long name by default"
longNames = False

#--------------------------
# Mel <---> Python Glue
#--------------------------	


def getMelGlobal( type, name ):
	"""get a mel global variable""" 
	if not name.startswith( '$'):
		name = '$' + name
	ret_type = type
	decl_name = name
	if type.endswith('[]'):
		type = type[:-2]
		if not decl_name.endswith('[]'):
			decl_name += '[]'
		
	cmd = "global proc %s pymel_get_global() { global %s %s; return %s; } pymel_get_global();" % (ret_type, type, decl_name, name )
	#print cmd
	return mm.eval( cmd  )

def setMelGlobal( type, name, value ):
	"""set a mel global variable""" 
	if not name.startswith( '$'):
		name = '$' + name
	decl_name = name
	if type.endswith('[]'):
		type = type[:-2]
		decl_name += '[]'
		
	cmd = "global %s %s; %s=%s;" % ( type, decl_name, name, pythonToMel(value) )
	#print cmd
	return mm.eval( cmd  )
	
def catch( func ):
	"""Reproduces the behavior of the mel command of the same name. if writing pymel scripts from scratch, you should
	really use the try/except structure. This command is provided for python scripts generated by py2mel"""
	try:
		func()
		return 0
	except:
		return 1

def feof( fileid ):
	"""Reproduces the behavior of the mel command of the same name. if writing pymel scripts from scratch, 
	you should use a more pythonic construct for looping through files:
	
	>>> f = open('myfile.txt')
	>>> for line in f:
	>>> 	print line
	
	This command is provided for python scripts generated by py2mel"""
	
	os = fileid.tell()
	f.seek(0,2) # goto end of file
	end = fileid.tell() #get final position
	fileid.seek(pos)
	return pos == end

from scanf import fscanf
					
#--------------------------
# Maya.mel Wrapper
#--------------------------

def pythonToMel(arg):
	if isinstance(arg,basestring):
		return '"%s"' % cmds.encodeString(arg)
	elif util.isIterable(arg):
		return '{%s}' % ','.join( map( pythonToMel, arg) ) 
	return unicode(arg)
	
class Mel(object):
	"""This class is a necessity for calling mel scripts from python. It allows scripts to be called
	in a cleaner fashion, by automatically formatting python arguments into a string 
	which is executed via maya.mel.eval().  An instance of this class is already created for you 
	when importing pymel and is called mel.  
	
	default:		
		>>> import maya.mel as mel
		>>> mel.eval( 'myScript("firstArg", 2, 3.0, {"one", "two", "three"})')
			
	pymel:
		>>> from pymel import *
		>>> mel.myScript("firstArg", 2, 3.0, ['one', 'two', 'three'])
		
	the advantages of this method are more readily apparent in a more complicated example:
	
	default:		
		>>> import cmds as cmds
		>>> node = "lambert1"
		>>> color = cmds.getAttr( node + ".color" )[0]
		>>> mel.eval('myScript("%s",{%s,%s,%s})' % (cmds.nodeType(node), color[0], color[1], color[2])	
			
	pymel:
		>>> from pymel import *
		>>> node = DependNode("lambert")
		>>> mel.myScript( node.type(), node.color.get() )
	
	from this you can see how pymel.mel allows you to pass any python object directly to your mel script as if 
	it were a python script, with no need for formatting arguments.
	"""
			
	def __getattr__(self, command):
		if command.startswith('__') and command.endswith('__'):
			return self.__dict__[command]
		def _call(*args):
		
			strArgs = map( pythonToMel, args)
							
			cmd = '%s(%s)' % ( command, ','.join( strArgs ) )
			#print cmd
			try:
				return mm.eval(cmd)
			except RuntimeError, msg:
				info = self.whatIs( command )
				if info.startswith( 'Presumed Mel procedure'):
					raise NameError, 'Unknown Mel procedure'
				raise RuntimeError, msg
			
		return _call
	
	def mprint(self, *args):
		"""mel print command in case the python print command doesn't cut it. i have noticed that python print does not appear
		in certain output, such as the rush render-queue manager."""
		#print r"""print (%s\\n);""" % pythonToMel( ' '.join( map( str, args))) 
		mm.eval( r"""print (%s);""" % pythonToMel( ' '.join( map( str, args))) + '\n' )
		
	def source( self, script ):
		"""use this to source mel scripts from within mel"""
		mm.eval( """source "%s";""" % script )
		
	def eval( self, command ):
		mm.eval( command )	
		
	def tokenize(self, *args ):
		raise NotImplementedError, "Calling the mel command 'tokenize' from python will crash Maya. Use the string split method instead."
mel = Mel()


#-----------------------------------------------
#  Workspace Class
#-----------------------------------------------

class WorkspaceEntryDict(object):
	def __init__(self, entryType):
		self.entryType = entryType
	def __getitem__(self, item):
		res = cmds.workspace( item, **{'q' : 1, self.entryType + 'Entry' : 1 } )
		if not res:
			raise KeyError, item
		return res
	def __setitem__(self, item, value):
		return cmds.workspace( item, **{'q' : 1, self.entryType: [item, value] } )
	def __contains__(self, key):
		return key in self.keys()
	def items(self):	
		entries = util.listForNone( cmds.workspace( **{'q' : 1, self.entryType : 1 } ) )
		res = []
		for i in range( 0, len(entries), 2):
			res.append( (entries[i], entries[i+1] ) )
		return res
	def keys(self):	
		return cmds.workspace( **{'q' : 1, self.entryType + 'List': 1 } )
	def values(self):	
		entries = util.listForNone( cmds.workspace( **{'q' : 1, self.entryType : 1 } ) )
		res = []
		for i in range( 0, len(entries), 2):
			res.append( entries[i+1] )
		return res
	def get(self, item, default=None):
		try:
			return self.__getitem__(item)
		except KeyError:
			return default
	has_key = __contains__
		
	
class Workspace(util.Singleton):
	"""
	This class is designed to lend more readability to the often confusing workspace command.
	The four types of workspace entries (objectType, fileRule, renderType, and variable) each
	have a corresponding dictiony for setting and accessing these mappings.
	
		>>> from pymel import *
		>>> workspace.renderTypes['audio']
		sound
		>>> workspace.renderTypes.keys()
		[u'3dPaintTextures', u'audio', u'clips', u'depth', u'images', u'iprImages', u'lights', u'mentalRay', u'particles', u'renderScenes', u'sourceImages', u'textures']
		>>> 'DXF' in workspace.fileRules
		True
		>>> workspace.fileRules['DXF']
		data
		>>> workspace.fileRules['super'] = 'data'
		>>> workspace.fileRules.get( 'foo', 'data' )
		data
		
	the workspace dir can be confusing because it works by maintaining a current working directory that is persistent
	between calls to the command.  In other words, it works much like the unix 'cd' command, or python's 'os.chdir'.
	In order to clarify this distinction, the names of these flags have been changed in their class method counterparts
	to resemble similar commands from the os module.
	
	old way (still exists for backward compatibility)
		>>> workspace(edit=1, dir='mydir')
		>>> workspace(query=1, dir=1)
		>>> workspace(create='mydir')
	
	new way	
		>>> workspace.chdir('mydir')
		>>> workspace.getcwd()	
		>>> workspace.mkdir('mydir')
	
	All paths are returned as an Path class, which makes it easy to alter or join them on the fly.	
		>>> workspace.path / workspace.fileRules['DXF']
		/Users/chad/Documents/maya/projects/default/path
		
	"""
	
 	objectTypes = WorkspaceEntryDict( 'objectType' )
 	fileRules 	= WorkspaceEntryDict( 'fileRule' )
	renderTypes = WorkspaceEntryDict( 'renderType' )
	variables 	= WorkspaceEntryDict( 'variable' )
	
	def __init__(self):
	 	self.objectTypes = WorkspaceEntryDict( 'objectType' )
	 	self.fileRules 	= WorkspaceEntryDict( 'fileRule' )
		self.renderTypes = WorkspaceEntryDict( 'renderType' )
		self.variables 	= WorkspaceEntryDict( 'variable' )
	
	@classmethod
	def open(self, workspace):
		return cmds.workspace( workspace, openWorkspace=1 )
	@classmethod
	def save(self):
		return cmds.workspace( saveWorkspace=1 )
	@classmethod
	def update(self):
		return cmds.workspace( update=1 )
	@classmethod
	def new(self, workspace):
		return cmds.workspace( workspace, newWorkspace=1 )		
	@classmethod
	def getName(self):
		return cmds.workspace( q=1, act=1 )

	@classmethod
	def getPath(self):
		return Path(cmds.workspace( q=1, fn=1 ))
	
	@classmethod
	def chdir(self, newdir):
		return cmds.workspace( dir=newdir )
	@classmethod
	def getcwd(self):
		return Path(cmds.workspace( q=1, dir=1 ))
	@classmethod
	def mkdir(self, newdir):
		return cmds.workspace( cr=newdir )

	name = property( lambda x: cmds.workspace( q=1, act=1 ) )		
	path = property( lambda x: Path(cmds.workspace( q=1, fn=1 ) ) )
			
	def __call__(self, *args, **kwargs):
		"""provides backward compatibility with cmds.workspace by allowing an instance
		of this class to be called as if it were a function"""
		return cmds.workspace( *args, **kwargs )

workspace = Workspace()

#-----------------------------------------------
#  FileInfo Class
#-----------------------------------------------

class FileInfo( util.Singleton ):
	"""
	store and get custom data specific to this file:
	
		>>> fileInfo['lastUser'] = env.user()
		
	if the python structures have valid __repr__ functions, you can
	store them and reuse them later:
	
		>>> fileInfo['cameras'] = str( ls( cameras=1) )
		>>> camList = eval(fileInfo['cameras'])
		>>> camList[0]
		# Result: frontShape #
		>>> camList[0].getFocalLength()  # it's still a valid pymel class
		# Result: 35.0 #
	
	for backward compatibility it retains it's original syntax as well:
		
		>>> fileInfo( 'myKey', 'myData' )
		
	"""
	
	def __contains__(self, item):
		return item in self.keys()
		
	def __getitem__(self, item):
		return dict(self.items())[item]
		
	def __setitem__(self, item, value):
		cmds.fileInfo( item, value )
	
	def __call__(self, *args, **kwargs):
		if kwargs.get('query', kwargs.get('q', False) ):
			return self.items()
		else:
			cmds.FileInfo( *args, **kwargs )
			
	def items(self):
		res = cmds.fileInfo( query=1)
		newRes = []
		for i in range( 0, len(res), 2):
			newRes.append( (res[i], res[i+1]) )
		return newRes
		
	def keys(self):
		res = cmds.fileInfo( query=1)
		newRes = []
		for i in range( 0, len(res), 2):
			newRes.append(  res[i] )
		return newRes
			
	def values(self):
		res = cmds.fileInfo( query=1)
		newRes = []
		for i in range( 0, len(res), 2):
			newRes.append( res[i+1] )
		return newRes
	
	def pop(self, *args):
		if len(args) > 2:
			raise TypeError, 'pop expected at most 2 arguments, got %d' % len(args)
		elif len(args) < 1:
			raise TypeError, 'pop expected at least 1 arguments, got %d' % len(args)
		
		if args[0] not in self.keys():
			try:
				return args[1]
			except IndexError:
				raise KeyError, args[0]
					
		cmds.fileInfo( rm=args[0])
	
	has_key = __contains__	
fileInfo = FileInfo()

#-----------------------------------------------
#  Option Variables
#-----------------------------------------------

class OptionVarList(list):
	def __init__(self, val, key):
		self.key = key
		list.__init__(self, val)
	def appendVar( self, val ):
		""" values appended to the OptionVarList with this method will be added to the Maya optionVar at the key denoted by self.key.
		The append function is still available for normal list operations.  This method is provided in addtion to the
		append method to prevent the user from retrieiving an OptionVarList and unknowingly altering option variables."""

		if isinstance( val, basestring):
			return cmds.optionVar( stringValueAppend=[self.key,val] )
		if isinstance( val, int):
			return cmds.optionVar( intValueAppend=[self.key,val] )
		if isinstance( val, float):
			return cmds.optionVar( floatValueAppend=[self.key,val] )
		raise TypeError, 'unsupported datatype: strings, ints, floats and their subclasses are supported'


class OptionVarDict(util.Singleton):
	""" 
	A singleton dictionary-like class for accessing and modifying optionVars:
	 
		>>> from pymel import *
		>>> optionVar['test'] = 'dooder'
		>>> print optionVar['test'] 
		u'dooder'
		
		>>> if 'numbers' not in env.optionVars:
		>>> 	optionVar['numbers'] = [1,24,7]
		>>> optionVar['numbers'].append( 9 )
		>>> numArray = optionVar.pop('numbers') 
		>>> print numArray
		[1,24,7,9]
		>>> optionVar.has_key('numbers') # previous pop removed the key
		False
	"""

	def __contains__(self, key):
		return cmds.optionVar( exists=key )
			
	def __getitem__(self,key):
		val = cmds.optionVar( q=key )
		if isinstance(val, list):
			val = OptionVarList( val, key )
		return val
	def __setitem__(self,key,val):
		if isinstance( val, basestring):
			return cmds.optionVar( stringValue=[key,val] )
		if isinstance( val, int) or isinstance( val, bool):
			return cmds.optionVar( intValue=[key,int(val)] )
		if isinstance( val, float):
			return cmds.optionVar( floatValue=[key,val] )
		if isinstance( val, list ):
			if len(val) == 0:
				return cmds.optionVar( clearArray=key )
			if isinstance( val[0], basestring):
				cmds.optionVar( stringValue=[key,val[0]] ) # force to this datatype
				for elem in val[1:]:
					if not isinstance( elem, basestring):
						raise TypeError, 'all elements in list must be of the same datatype'
					cmds.optionVar( stringValueAppend=[key,elem] )
				return
			if isinstance( val[0], int):
				cmds.optionVar(  intValue=[key,val[0]] ) # force to this datatype
				for elem in val[1:]:
					if not isinstance( elem, int):
						raise TypeError,  'all elements in list must be of the same datatype'
					print 'appending int', key, elem
					cmds.optionVar( intValueAppend=[key,elem] )
				return
			if isinstance( val[0], float):
				cmds.optionVar( floatValue=[key,val[0]] ) # force to this datatype
				for elem in val[1:]:
					if not isinstance( elem, foat):
						raise TypeError, 'all elements in list must be of the same datatype'
					cmds.optionVar( floatValueAppend=[key,elem] )
				return

		raise TypeError, 'unsupported datatype: strings, ints, float, lists, and their subclasses are supported'			

	def __delitem__(self,key):
		cmds.optionVar(remove=key)
	
	def keys(self):
		return cmds.optionVar( list=True )

	def get(self, key, default=None):
		if self.has_key(key):
			return self[key]
		else:
			return default
		
	def has_key(self, key):
		return cmds.optionVar( exists=key )

	def pop(self, key):
		val = cmds.optionVar( q=key )
		cmds.optionVar( remove=key )
		return val
	
optionVar = OptionVarDict()

#-----------------------------------------------
#  Global Settings
#-----------------------------------------------


class Env(util.Singleton):
	""" A Singleton class to represent Maya current optionVars and settings """
	optionVars = OptionVarDict()
	#grid = Grid()
	#playbackOptions = PlaybackOptions()
	environ = os.environ

	def setConstructionHistory( self, state ):
		cmds.constructionHistory( tgl=state )
	def getConstructionHistory(self):
		return cmds.constructionHistory( q=True, tgl=True )	
	def sceneName(self):
		return Path(cmds.file( q=1, sn=1))

	def setUpAxis( axis, rotateView=False ):
		"""This flag specifies the axis as the world up direction. The valid axis are either 'y' or 'z'."""
		cmds.upAxis( axis=axis, rotateView=rotateView )
	
	def getUpAxis(self):
		"""This flag gets the axis set as the world up direction. The valid axis are either 'y' or 'z'."""
		return cmds.upAxis( q=True, axis=True )	

	def user(self):
		return getuser()	
	def host(self):
		return gethostname()
	
	def getTime( self ):
		return cmds.currentTime( q=1 )
	def setTime( self, val ):
		cmds.currentTime( val )	
	time = property( getTime, setTime )

	def getMinTime( self ):
		return cmds.playbackOptions( q=1, minTime=1 )
	def setMinTime( self, val ):
		cmds.playbackOptions( minTime=val )
	minTime = property( getMinTime, setMinTime )

	def getMaxTime( self ):
		return cmds.playbackOptions( q=1, maxTime=1 )
	def setMaxTime( self, val ):
		cmds.playbackOptions( maxTime=val )	
	maxTime = property( getMaxTime, setMaxTime )
			
env = Env()

#-----------------------------------------------
#  Scene Class
#-----------------------------------------------

class Scene(util.Singleton):
	def __getattr__(self, obj):
		return node.PyNode( obj )

SCENE = Scene()


#-----------------------------------------------
#  Enhanced Commands
#-----------------------------------------------

#-----------------------
#  Object Manipulation
#-----------------------
def select(*args, **kwargs):
	"""
Modifications:
	- passing an empty list no longer causes an error. instead, the selection is simply cleared
	
	"""
	
	try:
		cmds.select(*args, **kwargs)
	except TypeError, msg:
		if args == ([],):
			cmds.select(cl=True)
		else:
			raise TypeError, msg
#select.__doc__ = mel.help('select') + select.__doc__

def move(obj, *args, **kwargs):
	"""
Modifications:
	- allows any iterable object to be passed as first argument::
	
		move("pSphere1", [0,1,2])
		
NOTE: this command also reorders the argument order to be more intuitive, with the object first
	"""
	if len(args) == 1 and util.isIterable(args[0]):
		args = tuple(args[0])
	args = args + (obj,)
	return cmds.move(*args, **kwargs)

def scale(obj, *args, **kwargs):
	"""
Modifications:
	- allows any iterable object to be passed as first argument::
	
		scale("pSphere1", [0,1,2])
		
NOTE: this command also reorders the argument order to be more intuitive, with the object first
	"""
	if len(args) == 1 and util.isIterable(args[0]):
		args = tuple(args[0])
	args = args + (obj,)
	return cmds.scale(*args, **kwargs)
	
def rotate(obj, *args, **kwargs):
	"""
Modifications:
	- allows any iterable object to be passed as first argument::
	
		rotate("pSphere1", [0,1,2])
		
NOTE: this command also reorders the argument order to be more intuitive, with the object first
	"""
	if len(args) == 1 and util.isIterable(args[0]):
		args = tuple(args[0])
	args = args + (obj,)
	return cmds.rotate(*args, **kwargs)



#-----------------------
#  Attributes
#-----------------------
		
def connectAttr( source, destination, **kwargs ):
	"""
Maya Bug Fix: 
	- even with the 'force' flag enabled, the command would raise an error if the connection already existed. 
	
	"""
	if kwargs.get('force', False) or kwargs.get('f', False):	
		try:
			cmds.connectAttr( source, destination, **kwargs )
		except RuntimeError:
			pass
	else:
		cmds.connectAttr( source, destination, **kwargs )

def disconnectAttr( source, destination=None, **kwargs ):
	"""
Modifications:
	- If no destination is passed, all inputs and outputs will be disconnected from the attribute
	"""
	source = node.Attribute(source)
	if destination:
		return cmds.disconnectAttr( source, destination, **kwargs )
	else:
		for source, destination in source.outputs( connections=True, plugs=True ):
			cmds.disconnectAttr( source, destination, **kwargs )
			
		for destination, source in source.inputs( connections=True, plugs=True ):
			cmds.disconnectAttr( source, destination, **kwargs )	
		
def getAttr( attr, **kwargs ):
	"""
Maya Bug Fix:
	- maya pointlessly returned vector results as a tuple wrapped in 
		a list ( ex.  '[(1,2,3)]' ). This command unpacks the vector for you.
Modifications:
	- casts double3 datatypes to Vector
	- casts matrix datatypes to Matrix
	- casts vectorArrays from a flat array of floats to an array of Vectors
	- when getting a multi-attr, maya would raise an error, but pymel will return a list of
	 	values for the multi-attr
	"""
	def listToMat( l ):
		return Matrix(
			[ 	[	l[0], l[1], l[2], l[3]	],
			[	l[4], l[5], l[6], l[7]	],
			[	l[8], l[9], l[10], l[11]	],
			[	l[12], l[13], l[14], l[15] ]	])
	
	def listToVec( l ):
		vecRes = []
		for i in range( 0, len(res), 3):
			vecRes.append( Vector( res[i:i+3] ) )
		return vecRes
	
	try:
		res = cmds.getAttr( attr, **kwargs)
		
		if isinstance(res, list) and len(res):
			if isinstance(res[0], tuple):
				res = res[0]
				if cmds.getAttr( attr, type=1) == 'double3':
					return Vector(list(res))
			#elif cmds.getAttr( attr, type=1) == 'matrix':
			#	return listToMat(res)
			else:
				try:
					return { 
						'matrix': listToMat,
						'vectorArray' : listToVec
						}[cmds.getAttr( attr, type=1)](res)
				except KeyError: pass
		return res
	
	# perhaps it errored because it's a multi attribute
	except RuntimeError, msg:
		attr = node.Attribute(attr)
		if attr.isMulti():
			return [attr[i].get() for i in range(attr.size())]
		raise RuntimeError, msg


	
# getting and setting					
def setAttr( attr, *args, **kwargs):
	"""
Maya Bug Fix:
	- setAttr did not work with type matrix. 
Modifications:
	- No need to set type, this will automatically be determined
 	- Adds support for passing a list or tuple as the second argument for datatypes such as double3.
	- When setting stringArray datatype, you no longer need to prefix the list with the number of elements - just pass a list or tuple as with other arrays
	- Added 'force' kwarg, which causes the attribute to be added if it does not exist. 
		- if no type flag is passed, the attribute type is based on type of value being set (if you want a float, be sure to format it as a float, e.g.  3.0 not 3)
		- currently does not support compound attributes
		- currently supported python-to-maya mappings:		
			- float 	S{->} double
			- int		S{->} long
			- str		S{->} string
			- bool		S{->} bool
			- Vector	S{->} double3
			- Matrix	S{->} matrix
			- [str]		S{->} stringArray
	"""
	datatype = kwargs.get( 'type', kwargs.get( 'typ', None) )
	
	# if there is only one argument we do our special pymel tricks
	if len(args) == 1:
		
		arg = args[0]
		
		# force flag
		force = kwargs.pop('force', kwargs.pop('f', False) )
		
		
		# vector, matrix, and arrays
		if util.isIterable(arg):
								
			if datatype is None:
				# if we're using force flag and the attribute does not exist
				# we can infer the type from the passed value
				attr = node.Attribute(attr)
				if force and not attr.exists():
					
					try:
						if isinstance( arg[0], basestring ):
							datatype = 'stringArray'
						#elif isinstance( arg[0], int ):
						#	datatype = 'Int32Array'
						#elif isinstance( arg[0], float ):
						#	datatype = 'doubleArray'	
						elif isinstance( arg[0], list ):
							datatype = 'vectorArray'
						elif isinstance( arg, Vector):
							datatype = 'double3'
						elif isinstance( arg, Matrix ):
							datatype = 'matrix'
						else:
							raise ValueError, "pymel.setAttr: %s is not a supported type for use with the force flag" % type(arg[0])
												
						print "adding", attr, datatype
						attr.add( dt=datatype ) 
						kwargs['type'] = datatype
						
					# empty array is being passed
					# if the attribute exists, this is ok
					except IndexError:
						raise ValueError, "pymel.setAttr: when setting 'force' keyword to create a new array attribute, you must provide an array with at least one element"  					
					
					except TypeError:
						raise ValueError, "pymel.setAttr: %s is not a supported type" % type(args)
					
					kwargs['type'] = datatype
				
				else:
					if isinstance( arg, Vector):
						datatype = 'double3'
					elif isinstance( arg, Matrix ):
						datatype = 'matrix'
					else:		
						datatype = cmds.getAttr( attr, type=1)
						if not datatype:
							#print "Getting datatype", attr
							datatype = cmds.addAttr( attr, q=1, dataType=1)[0] # this is returned as a single element list
					
						# set datatype for arrays
						# we could do this for all, but i'm uncertain that it needs to be 
						# done and it might cause more problems
						if datatype.endswith('Array'):
							kwargs['type'] = datatype
		
			
			# string arrays:
			#	first arg must be the length of the array being set
			# ex:
			# 	setAttr('loc.strArray',["first", "second", "third"] )	
			# becomes:
			# 	cmds.setAttr('loc.strArray',3,"first", "second", "third",type='stringArray')
			if datatype == 'stringArray':
				args = tuple( [len(arg)] + arg )
			
			# vector arrays:
			#	first arg must be the length of the array being set
			#	empty values are placed between vectors
			# ex:
			# 	setAttr('loc.vecArray',[1,2,3],[4,5,6],[7,8,9] )	
			# becomes:
			# 	cmds.setAttr('loc.vecArray',3,[1,2,3],"",[4,5,6],"",[7,8,9],type='vectorArray')
			elif datatype == 'vectorArray':			
				arg = list(arg)
				size = len(arg)
				try:
					tmpArgs = [arg.pop(0)]
					for filler, real in zip( [""]*(size-1), arg ):
						tmpArgs.append( filler )
						tmpArgs.append( real )
				except IndexError:
					tmpArgs = []
							
				args = tuple( [size] + tmpArgs )
				#print args

			# others: 
			#	args must be expanded
			# ex:
			# 	setAttr('loc.foo',[1,2,3] )	
			# becomes:
			# 	cmds.setAttr('loc.foo',1,2,3 )	
			else:
				args = tuple(arg)
				
		# non-iterable types
		else:
			if datatype is None:
				attr = node.Attribute(attr)	
				if force and not attr.exists(): 
					if isinstance( arg, basestring ):
						attr.add( dt='string' )
						kwargs['type'] = 'string'
					elif isinstance( arg, int ):
						attr.add( at='long' ) 
					elif isinstance( arg, float ):
						attr.add( at='double' ) 
					elif isinstance( arg, bool ):
						attr.add( at='bool' ) 
					else:
						raise TypeError, "pymel.setAttr: %s is not a supported type for use with the force flag" % type(arg)
										
				elif isinstance(arg,basestring):
					kwargs['type'] = 'string'

	if datatype == 'matrix':
		cmd = 'setAttr -type "matrix" "%s" %s' % (attr, ' '.join( map( str, args ) ) )
		mm.eval(cmd)
		return					
	cmds.setAttr( attr, *args, **kwargs)

def addAttr( *args, **kwargs ):
	"""
Modifications:
	- allow python types to be passed to set -at type
			str		S{->} string
			float 	S{->} double
			int		S{->} long
			bool	S{->} bool
			Vector	S{->} double3
	- when querying dataType, the dataType is no longer returned as a list
	"""
	at = kwargs.pop('attributeType', kwargs.pop('at', None ))
	if at is not None:
		try: 
			kwargs['at'] = {
				float: 'double',
				int: 'long',
				bool: 'bool',
				Vector: 'double3',
				str: 'string',
				unicode: 'string'
			}[at]
		except KeyError:
			kwargs['at'] = at
			
	res = cmds.addAttr( *args, **kwargs )
	if kwargs.get( 'q', kwargs.get('query',False) ) and kwargs.get( 'dt', kwargs.get('dataType',False) ):
		res = res[0]
	
	return res

#-----------------------
#  List Functions
#-----------------------
		
def listConnections(*args, **kwargs):
	"""
Modifications:
	- returns an empty list when the result is None
	- When 'connections' flag is True, the attribute pairs are returned in a 2D-array::
	
		[['checker1.outColor', 'lambert1.color'], ['checker1.color1', 'fractal1.outColor']]
		
	- added sourceFirst keyword arg. when sourceFirst is true and connections is also true, 
		the paired list of plugs is returned in (source,destination) order instead of (thisnode,othernode) order.
		this puts the pairs in the order that disconnectAttr and connectAttr expect.
	"""
	def makePairs(l):
		res = []
		if l is None:
			return res
			
		for i in range(0, len(l),2):
			res.append( ( node.PyNode(l[i]), node.PyNode(l[i+1]) )  )
		return res
		
	if kwargs.get('connections', kwargs.get('c', False) ) :	
		
				
		if kwargs.pop('sourceFirst',False):
			source = kwargs.get('source', kwargs.get('s', True ) )
			dest = kwargs.get('destination', kwargs.get('d', True ) )

			if source:				
				if not dest:
					return [ (s, d) for d, s in makePairs( cmds.listConnections( *args,  **kwargs ) ) ]
				else:
					res = []
					kwargs.pop('destination', None)
					kwargs['d'] = False					
					res = [ (s, d) for d, s in makePairs(cmds.listConnections( *args,  **kwargs )) ]					

					kwargs.pop('source', None)
					kwargs['s'] = False
					kwargs['d'] = True
					return makePairs(cmds.listConnections( *args,  **kwargs )) + res
					
			# if dest passes through to normal method 
			
		return makePairs( cmds.listConnections( *args,  **kwargs ) )

	else:
		return map(node.PyNode, util.listForNone(cmds.listConnections( *args,  **kwargs )) )

def listHistory( *args, **kwargs ):
	"""
Modifications:
	- returns an empty list when the result is None
	- added a much needed 'type' filter
	"""
	
	if 'type' in kwargs:
		typ = kwargs.pop('type')
		return filter( lambda x: cmds.nodeType(x) == typ, map( node.PyNode, cmds.listHistory( *args,  **kwargs ) )  )
	return map(node.PyNode, util.listForNone(cmds.listHistory( *args,  **kwargs ) ) )

		
def listFuture( *args, **kwargs ):
	"""
Modifications:
	- returns an empty list when the result is None
	- added a much needed 'type' filter
	"""
	kwargs['future'] = True
	if 'type' in kwargs:
		typ = kwargs.pop('type')
		return filter( lambda x: cmds.nodeType(x) == typ, map( node.PyNode, cmds.listHistory( *args,  **kwargs ) )  )
	return map(node.PyNode, util.listForNone(cmds.listHistory( *args,  **kwargs )) )

		
def listRelatives( *args, **kwargs ):
	"""
Maya Bug Fix
	- allDescendents and shapes flags did not work in combination
	
Modifications:
	- returns an empty list when the result is None
	- returns wrapped classes
	"""
	
	if kwargs.get( 'allDescendents', kwargs.get('ad', False) ) and kwargs.pop( 'shapes', kwargs.pop('s', False) ):		
		kwargs['fullPath'] = True
		kwargs.pop('f', None)

		res = cmds.listRelatives( *args, **kwargs)
		if res is None:
			return
		return ls( res, shapes=1)

	if longNames:
		kwargs['fullPath'] = True
		kwargs.pop('f', None)
				
	return map(node.PyNode, util.listForNone(cmds.listRelatives(*args, **kwargs)))


def ls( *args, **kwargs ):
	"""
Modifications:
	- Added new keyword: 'editable' - this will return the inverse set of the readOnly flag. i.e. non-read-only nodes
	"""
	if longNames:
		kwargs['long'] = True
		kwargs.pop('l', None)
	
	if kwargs.pop('editable', False):
		allNodes = util.listForNone(cmds.ls(*args, **kwargs))
		kwargs['readOnly'] = True
		kwargs.pop('ro',True)
		roNodes = util.listForNone(cmds.ls(*args, **kwargs))
		
		# faster way?
		return map( node.PyNode, filter( lambda x: x not in roNodes, allNodes ) )
	
	# this has been removed because the method below
	# is 3x faster because it gets the node type along with the node list
	# unfortunately, it's still about 2x slower than cmds.ls
	#return map(node.PyNode, util.listForNone(cmds.ls(*args, **kwargs)))
	
	if kwargs.get( 'readOnly', kwargs.get('ro', False) ):
		# when readOnly is provided showType is ignored
		return map(node.PyNode, util.listForNone(cmds.ls(*args, **kwargs)))
		
	if kwargs.get( 'showType', kwargs.get('st', False) ):
		tmp = util.listForNone(cmds.ls(*args, **kwargs))
		res = []
		for i in range(0,len(tmp),2):
			res.append( node.PyNode( tmp[i], tmp[i+1] ) )
			res.append( tmp[i+1] )
		return res	
		
	kwargs['showType'] = True
	tmp = util.listForNone(cmds.ls(*args, **kwargs))
	res = []
	for i in range(0,len(tmp),2):
		res.append( node.PyNode( tmp[i], tmp[i+1] ) )
	
	return res
	
	'''
	showType = kwargs.get( 'showType', kwargs.get('st', False) )
	kwargs['showType'] = True
	kwargs.pop('st',None)	
	res = []
	if kwargs.get( 'readOnly', kwargs.get('ro', False) ):
		
		ro = cmds.ls(*args, **kwargs) # showType flag will be ignored
		
		# this was unbelievably slow
		
		kwargs.pop('readOnly',None)
		kwargs.pop('ro',None)
		all = cmds.ls(*args, **kwargs)
		for node in ro:
			try:	
				idx = all.index(node)
				all.pop(idx)
				typ = all.pop(idx+1)
				res.append( node.PyNode( node, typ ) ) 
				if showType:
					res.append( typ )
			except ValueError: pass
		return res
	else:
		tmp = util.listForNone(cmds.ls(*args, **kwargs))
		for i in range(0,len(tmp),2):
			typ = tmp[i+1]
			res.append( node.PyNode( tmp[i],  ) )	
			if showType:
				res.append( typ )
		
		return res
	'''
	
def lsThroughFilter( *args, **kwargs):
	"""
Modifications:
	- returns an empty list when the result is None
	- returns wrapped classes
	"""
	return map(node.PyNode, util.listForNone(cmds.lsThroughFilter(*args, **kwargs)))

	#for i in cmds.ls(*args, **kwargs):
	#	yield node.PyNode(i)

def listTransforms( *args, **kwargs ):
	"""
Modifications:
	- returns wrapped classes
	"""

	res = cmds.listRelatives(  cmds.ls(*args, **kwargs), p=1, path=1 )
	return map( node.PyNode, res, ['transform']*len(res) )

def listAnimatable( *args, **kwargs ):
	"""
Modifications:
	- returns an empty list when the result is None
	- returns wrapped classes
	"""
	return map( node.Attribute, util.listForNone(cmds.listAnimatable( *args, **kwargs ) ) )
	
#-----------------------
#  Objects
#-----------------------

def group( *args, **kwargs ):
	"""
Modifications
	- if no objects are provided for grouping, the empty flag is automatically set
	"""
	if not args and not cmds.ls(sl=1):
		kwargs['empty'] = True
	return node.Transform( cmds.group(*args, **kwargs) )
	#except RuntimeError, msg:
	#	print msg
	#	if msg == 'Not enough objects or values.':
	#		kwargs['empty'] = True
	#		return node.Transform( cmds.group(**kwargs) )

def duplicate( *args, **kwargs ):
	"""
Modifications:
	- returns wrapped classes
	"""
	return map(node.PyNode, cmds.duplicate( *args, **kwargs ) )

	
def instance( *args, **kwargs ):
	"""
Modifications:
	- returns wrapped classes
	"""
	return map(node.PyNode, cmds.instance( *args, **kwargs ) )	

'''		
def attributeInfo( *args, **kwargs ):
	"""
Modifications:
	- returns an empty list when the result is None
	- returns wrapped classes
	"""
	
	return map(node.PyNode, util.listForNone(cmds.attributeInfo(*args, **kwargs)))
'''

def rename( obj, newname, **kwargs):
	"""
Modifications:
	- if the full path to an object is passed as the new name, the shortname of the object will automatically be used
	"""
	
	if isinstance( newname, node.DagNode ):
		newname = newname.shortName()
		
	return node.PyNode( cmds.rename( obj, newname, **kwargs ) )
	
def createNode( *args, **kwargs):
	return node.PyNode( cmds.createNode( *args, **kwargs ) )
			
def shadingNode( *args, **kwargs):
	return node.PyNode( cmds.shadingNode( *args, **kwargs ) )
				
def sets( objectSet, **kwargs):
	"""
Modifications
	- resolved confusing syntax: operating set is always the first and only arg::
	
		sets( 'blinn1SG', forceElement=['pSphere1', 'pCube1'] )
		sets( 'blinn1SG', flatten=True )
		
	- returns wrapped classes
		
	"""
	setSetFlags = [
	'subtract', 'sub',
	'union', 'un',
	'intersection', 'int',	
	'isIntersecting', 'ii',
	'isMember', 'im',	
	'split', 'sp',	
	'noWarnings', 'nw',	
	'addElement', 'add',
	'include', 'in',
	'remove', 'rm',	
	'forceElement', 'fe'
	]
	setFlags = [
	'copy', 'cp',		
	'clear', 'cl',
	'flatten', 'fl'
	]
	
	args = (objectSet,)
	
	# 	this:
	#		sets('myShadingGroup', forceElement=1)
	#	must be converted to:
	#		sets(forceElement='myShadingGroup')
		
	for flag, value in kwargs.items():	
		if flag in setSetFlags:
			# move arg over to kwarg
			if util.isIterable(value):
				args = tuple(value)
			elif isinstance( value, basestring ):
				args = (value,)
			else:
				args = ()
			kwargs[flag] = objectSet
			break
		elif flag in setFlags:
			kwargs[flag] = args[0]
			args = ()
			
	if kwargs.get( 'query', kwargs.get('q',False) ):
		size = len(kwargs)
		if size == 1 or (size==2 and kwargs.get( 'nodesOnly', kwargs.get('no',False) )  ) :
			return map( node.PyNode, util.listForNone(cmds.sets( *args, **kwargs )) )
			
	return cmds.sets( *args, **kwargs )
	
	'''
	#try:
	#	elements = elements[0]
	#except:
	#	pass
	
	#print elements
	if kwargs.get('query', kwargs.get( 'q', False)):
		#print "query", kwargs, len(kwargs)
		if len(kwargs) == 1:
			# list of elements
			
			return set( cmds.sets( elements, **kwargs ) or [] )
		# other query
		return cmds.sets( elements, **kwargs )
		
	elif kwargs.get('clear', kwargs.get( 'cl', False)):		
		return cmds.sets( **kwargs )
	
	
	#if isinstance(elements,basestring) and cmds.ls( elements, sets=True):
	#	elements = cmds.sets( elements, q=True )
	
	#print elements, kwargs	
	nonCreationArgs = set([
				'edit', 'e',
				'isIntersecting', 'ii',
				'isMember', 'im',
				'subtract', 'sub',
				'union', 'un',
				'intersection', 'int'])
	if len( nonCreationArgs.intersection( kwargs.keys()) ):
		#print "creation"
		return cmds.sets( *elements, **kwargs )

	# Creation
	#args = _convertListArgs(args)
	#print "creation"
	return ObjectSet(cmds.sets( *elements, **kwargs ))
	'''
'''
def delete(*args, **kwargs):
	"""
Modifications:
	- if this is passed an empty list, tuple or other iterable object as the only argument, the command will no longer error
	"""
	if len(args) ==1 and util.isIterable(args[0]) and not args[0]:
		return
'''	
def currentTime( *args, **kwargs ):
	"""
Modifications:
	- if no args are provided, the command returns the current time -- the equivalent of::
	
		cmds.currentTime(q=1)
	"""
	
	if not args and not kwargs:
		return cmds.currentTime(q=1)
	else:
		return cmds.currentTime(*args, **kwargs)
			
def getClassifiction( *args ):
	"""
Modifications:
	- previously returned a list with a single colon-separated string of classificatins. now returns a list of classifications
	"""
	return cmds.getClassification(*args)[0].split(':')
	
def lsUI( **kwargs ):
	long = kwargs.pop( 'long', kwargs.pop( 'l', False ) )
	head = kwargs.pop( 'head', kwargs.pop( 'hd', None ) )
	tail = kwargs.pop( 'tail', kwargs.pop( 'tl', None) )
	
	if not kwargs:
		kwargs = { 
			'windows': 1, 'panels' : 1, 'editors' : 1, 'controls' : 1, 'controlLayouts' : 1,
			'collection' : 1, 'radioMenuItemCollections' : 1, 'menus' : 1, 'menuItems' : 1, 'contexts' : 1, 'cmdTemplates' : 1 }
	kwargs['long'] = long
	if head is not None: kwargs['head'] = head
	if tail is not None: kwargs['tail'] = tail
	return map( ui.PyUI, util.listForNone( cmds.lsUI( **kwargs ) ) )

#--------------------------
# New Commands
#--------------------------

def sceneName():
	#return Path(cmds.file( q=1, sn=1))
	return Path( OpenMaya.MFileIO.currentFile() )
def getCurrentTime():
	"""get the current time as a float"""
	return cmds.currentTime(q=1)
	
def setCurrentTime( time ):
	"""set the current time """
	return cmds.currentTime(time)

def selected( **kwargs ):
	"""ls -sl"""
	kwargs['sl'] = 1
	return ls( **kwargs )

def createSurfaceShader( shadertype, name=None ):
	classification = getClassification( shadertype )
	#print classification
	
	newShader = None
	#if 'shader/surface' in classification:		
	if 'rendernode/mentalray/material' in classification:
		newShader = node.DependNode(mel.mrCreateCustomNode( "-asShader", "", shadertype))
	else:
		newShader = node.DependNode(mel.renderCreateNode( "-asShader", "surfaceShader", shadertype, "", 0, 0, 0, 1, 0, ""))
	#else:
	#	raise TypeError, "%s is not a valid surface shader type. shader must be classified as 'shader/surface'" % shadertype
	sg = newShader.shadingGroups()[0]
	if name:
		newShader = newShader.rename(name)		
		sg = sg.rename( name + 'SG')
	return newShader, sg

#-----------------------------------------------
#  File Classes
#-----------------------------------------------
	
class Path(pathClass):
	"""A basic Maya file class. it gets most of its power from the path class written by Jason Orendorff.
	see path.py for more documentation."""
	def __repr__(self):
		return "%s('%s')" % (self.__class__.__name__, self)
	def writable(self):
		return cmds.file( self, q=1, writable=1 )
	def type(self):
		return cmds.file( self, q=1, type=1 )
		
class FileReference(Path):
	"""A class for manipulating references which inherits Path and path.  you can create an 
	instance by supplying the path to a reference file, its namespace, or its reference node to the 
	appropriate keyword. The namespace and reference node of the reference can be retreived via 
	the namespace and refNode properties. The namespace property can also be used to change the namespace
	of the reference. 
	
	Use listRefences command to return a list of references as instances of the FileReference class.
	
	It is important to note that instances of this class will have their copy number stripped off
	and stored in an internal variable upon creation.  This is to maintain compatibility with the numerous methods
	inherited from the path class which requires a real file path. When calling built-in methods of FileReference, 
	the path will automatically be suffixed with the copy number before being passed to maya commands, thus ensuring 
	the proper results in maya as well. 
	 """
	
	def __new__(cls, path=None, namespace=None, refnode=None):
		def create(path):
			def splitCopyNumber(path):
				"""Return a tuple with the path and the copy number. Second element will be None if no copy number"""
				buf = path.split('{')
				try:
					return ( buf[0], int(buf[1][:-1]) )
				except:
					return (path, None)
					
			path, copyNumber = splitCopyNumber(path)
			self = Path.__new__(cls, path)
			self._copyNumber = copyNumber
			return self
			
		if path:
			return create(path)
		if namespace:
			for path in map( FileReference, cmds.file( q=1, reference=1) ):
				 if path.namespace == namespace:
					return create(path)
			raise ValueError, "Namespace '%s' does not match any found in scene" % namespace
		if refnode:
			path = cmds.referenceQuery( refnode, filename=1 )
			return create(path)
		raise ValueError, "Must supply at least one argument"	

	def subReferences(self):
		namespace = self.namespace + ':'
		res = {}
		try:
			for x in cmds.file( self, q=1, reference=1):
				res[namespace + cmds.file( x, q=1, namespace=1)] = pymel.core.FileReference(x)
		except: pass
		return res	
		
		
	def namespaceExists(self):
		return cmds.namespace(ex=self.namespace)
		
	def withCopyNumber(self):
		"""return this path with the copy number at the end"""
		if self._copyNumber is not None:
			return Path( '%s{%d}' % (self, self._copyNumber) )
		return self
			
	def importContents(self):
		"""file -importReference """
		return cmds.file( self.withCopyNumber(), importReference=1 )
	def	remove(self):
		"""file -removeReference """
		return cmds.file( self.withCopyNumber(), removeReference=1 )
	def	unload(self):
		"""file -unloadReference """
		return cmds.file( self.withCopyNumber(), unloadReference=1 )	
	def	clean(self):
		"""file -cleanReference """
		return cmds.file( self.withCopyNumber(), cleanReference=1 )
	def	lock(self):
		"""file -lockReference """
		return cmds.file( self.withCopyNumber(), lockReference=1 )
	
	def isDeferred(self):
		"""file -q -deferReference """
		return cmds.file( self.withCopyNumber(), q=1, deferReference=1 )
	def isLoaded(self):
		return not cmds.file( self.withCopyNumber(), q=1, deferReference=1 )
	
	def nodes(self):
		"""referenceQuery -nodes """
		return map( node.PyNode, cmds.referenceQuery( self.withCopyNumber(), nodes=1 ) )
	def copyNumberList(self):
		"""returns a list of all the copy numbers of this file"""
		return cmds.file( self, q=1, copyNumberList=1 )
	def selectAll(self):
		"""file -selectAll"""
		return cmds.file( self.withCopyNumber(), selectAll=1 )
			
	def _getNamespace(self):
		return cmds.file( self.withCopyNumber(), q=1, ns=1)
	def _setNamespace(self, namespace):
		return cmds.file( self.withCopyNumber(), e=1, ns=namespace)	
	namespace = property( _getNamespace, _setNamespace )

	def _getRefNode(self):
		return node.DependNode(cmds.referenceQuery( self.withCopyNumber(), referenceNode=1 ))	
	refNode = util.cacheProperty( _getRefNode, '_refNode')

_thisModule = __import__(__name__, globals(), locals(), ['']) # last input must included for sub-modules to be imported correctly

def _createFunctions():
	for funcName in factories.moduleCmds['core']:
		func = factories.functionFactory( funcName, None )
		if func:
			func.__module__ = __name__
			setattr( _thisModule, funcName, func )
	for funcName in factories.getUncachedCmds():
		setattr( _thisModule, funcName, getattr( cmds, funcName) )
_createFunctions()

#factories.createFunctions( _thisModule, None )
