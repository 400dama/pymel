

import sys, os, re
try:
	import maya.cmds as cmds
	import maya.mel as mm
	import maya.OpenMaya as OpenMaya

except ImportError:
	pass


_thisModule = __import__(__name__)

#import factories
from vector import *
import util



try:
	from luma.filepath import filepath as Filepath
	pathClass = Filepath
except ImportError:
	import path
	pathClass = path.path

"controls wheter functions that return dag nodes use the long name by default"
longNames = False


#--------------------------
# Mel <---> Python Glue
#--------------------------	


def getMelGlobal( type, name ):
	"""get a mel global variable""" 
	if not name.startswith( '$'):
		name = '$' + name
	ret_type = type
	decl_name = name
	if type.endswith('[]'):
		type = type[:-2]
		if not decl_name.endswith('[]'):
			decl_name += '[]'
		
	cmd = "global proc %s pymel_get_global() { global %s %s; return %s; } pymel_get_global();" % (ret_type, type, decl_name, name )
	#print cmd
	return mm.eval( cmd  )

def setMelGlobal( type, name, value ):
	"""set a mel global variable""" 
	if not name.startswith( '$'):
		name = '$' + name
	decl_name = name
	if type.endswith('[]'):
		type = type[:-2]
		decl_name += '[]'
		
	cmd = "global %s %s; %s=%s;" % ( type, decl_name, name, pythonToMel(value) )
	#print cmd
	return mm.eval( cmd  )
	
def catch( func ):
	"""Reproduces the behavior of the mel command of the same name. if writing pymel scripts from scratch, you should
	really use the try/except structure. This command is provided primarily for python scripts generated by py2mel"""
	try:
		func()
		return 0
	except:
		return 1

							
#--------------------------
# Maya.mel Wrapper
#--------------------------

def pythonToMel(arg):
	if isinstance(arg,basestring):
		return '"%s"' % cmds.encodeString(arg)
	elif util.isIterable(arg):
		return '{%s}' % ','.join( map( pythonToMel, arg) ) 
	return unicode(arg)
	
class Mel(object):
	"""This class is a necessity for calling mel scripts from python. It allows scripts to be called
	in a cleaner fashion, by automatically formatting python arguments into a string 
	which is executed via maya.mel.eval().  An instance of this class is already created for you 
	when importing pymel and is called mel.  
	
	default:		
		>>> import maya.mel as mel
		>>> mel.eval( 'myScript("firstArg", 2, 3.0, {"one", "two", "three"})')
			
	pymel:
		>>> from pymel import *
		>>> mel.myScript("firstArg", 2, 3.0, ['one', 'two', 'three'])
		
	the advantages of this method are more readily apparent in a more complicated example:
	
	default:		
		>>> import cmds as cmds
		>>> node = "lambert1"
		>>> color = cmds.getAttr( node + ".color" )[0]
		>>> mel.eval('myScript("%s",{%s,%s,%s})' % (cmds.nodeType(node), color[0], color[1], color[2])	
			
	pymel:
		>>> from pymel import *
		>>> node = Node("lambert")
		>>> mel.myScript( node.type(), node.color.get() )
	
	from this you can see how pymel.mel allows you to pass any python object directly to your mel script as if 
	it were a python script, with no need for formatting arguments.
	"""
			
	def __getattr__(self, command):
		if command.startswith('__') and command.endswith('__'):
			return self.__dict__[command]
		def _call(*args):
		
			strArgs = map( pythonToMel, args)
							
			cmd = '%s(%s)' % ( command, ','.join( strArgs ) )
			#print cmd
			return mm.eval(cmd)
		return _call
	
	def mprint(self, *args):
		"""mel print command in case the python print command doesn't cut it. i have noticed that python print does not appear
		in certain output, such as the rush render-queue manager."""
		#print r"""print (%s\\n);""" % pythonToMel( ' '.join( map( str, args))) 
		mm.eval( r"""print (%s);""" % pythonToMel( ' '.join( map( str, args))) + '\n' )
		
	def source( self, script ):
		"""use this to source mel scripts from within mel"""
		mm.eval( """source "%s";""" % script )
		
	def eval( self, command ):
		mm.eval( command )	
		
mel = Mel()


#-----------------------------------------------
#  Scene Class
#-----------------------------------------------

class WorkspaceEntryDict(object):
	def __init__(self, entryType):
		self.entryType = entryType
	def __getitem__(self, item):
		res = cmds.workspace( item, **{'q' : 1, self.entryType + 'Entry' : 1 } )
		if not res:
			raise KeyError, item
		return res
	def __setitem__(self, item, value):
		return cmds.workspace( item, **{'q' : 1, self.entryType: [item, value] } )
	def __contains__(self, key):
		return key in self.keys()
	def items(self):	
		entries = util.listForNone( cmds.workspace( **{'q' : 1, self.entryType : 1 } ) )
		res = []
		for i in range( 0, len(entries), 2):
			res.append( (entries[i], entries[i+1] ) )
		return res
	def keys(self):	
		return cmds.workspace( **{'q' : 1, self.entryType + 'List': 1 } )
	def values(self):	
		entries = util.listForNone( cmds.workspace( **{'q' : 1, self.entryType : 1 } ) )
		res = []
		for i in range( 0, len(entries), 2):
			res.append( entries[i+1] )
		return res
	def get(self, item, default=None):
		try:
			return self.__getitem__(item)
		except KeyError:
			return default
	has_key = __contains__
		
	
class Workspace(util.Singleton):
	"""
	This class is designed to lend more readability to the often confusing workspace command.
	The four types of workspace entries (objectType, fileRule, renderType, and variable) each
	have a corresponding dictiony for setting and accessing these mappings.
	
		>>> from pymel import *
		>>> workspace.renderTypes['audio']
		sound
		>>> workspace.renderTypes.keys()
		[u'3dPaintTextures', u'audio', u'clips', u'depth', u'images', u'iprImages', u'lights', u'mentalRay', u'particles', u'renderScenes', u'sourceImages', u'textures']
		>>> 'DXF' in workspace.fileRules
		True
		>>> workspace.fileRules['DXF']
		data
		>>> workspace.fileRules['super'] = 'data'
		>>> workspace.fileRules.get( 'foo', 'data' )
		data
		
	the workspace dir can be confusing because it works by maintaining a current working directory that is persistent
	between calls to the command.  In other words, it works much like the unix 'cd' command, or python's 'os.chdir'.
	In order to clarify this distinction, the names of these flags have been changed in their class method counterparts
	to resemble similar commands from the os module::
	
	old way (still exists for backward compatibility)
		>>> workspace(edit=1, dir='mydir')
		>>> workspace(query=1, dir=1)
		>>> workspace(create='mydir')
	
	new way	
		>>> workspace.chdir('mydir')
		>>> workspace.getcwd()	
		>>> workspace.mkdir('mydir')
	
	All paths are returned as an Path class, which makes it easy to alter or join them on the fly.	
		>>> workspace.path / workspace.fileRules['DXF']
		/Users/chad/Documents/maya/projects/default/path
		
	"""
	
 	objectTypes = WorkspaceEntryDict( 'objectType' )
 	fileRules 	= WorkspaceEntryDict( 'fileRule' )
	renderTypes = WorkspaceEntryDict( 'renderType' )
	variables 	= WorkspaceEntryDict( 'variable' )
	
	def __init__(self):
	 	self.objectTypes = WorkspaceEntryDict( 'objectType' )
	 	self.fileRules 	= WorkspaceEntryDict( 'fileRule' )
		self.renderTypes = WorkspaceEntryDict( 'renderType' )
		self.variables 	= WorkspaceEntryDict( 'variable' )
	
	@classmethod
	def open(self, workspace):
		return cmds.workspace( workspace, openWorkspace=1 )
	@classmethod
	def save(self):
		return cmds.workspace( saveWorkspace=1 )
	@classmethod
	def update(self):
		return cmds.workspace( update=1 )
	@classmethod
	def new(self, workspace):
		return cmds.workspace( workspace, newWorkspace=1 )		
	@classmethod
	def getName(self):
		return cmds.workspace( q=1, act=1 )
	name = property( getName )

	@classmethod
	def getPath(self):
		return Path(cmds.workspace( q=1, fn=1 ))
	path = property( getPath )
	
	@classmethod
	def chdir(self, newdir):
		return cmds.workspace( dir=newdir )
	@classmethod
	def getcwd(self):
		return Path(cmds.workspace( q=1, dir=1 ))
	@classmethod
	def mkdir(self, newdir):
		return cmds.workspace( cr=newdir )
		
	def __call__(self, *args, **kwargs):
		"""provides backward compatibility with cmds.workspace by allowing an instance
		of this class to be called as if it were a function"""
		return cmds.workspace( *args, **kwargs )

workspace = Workspace()


class FileInfo( util.Singleton ):
	"""
	store and get custom data specific to this file:
	
		>>> fileInfo['lastUser'] = env.user()
		
	if the python structures have valid __repr__ functions, you can
	store them and reuse them later:
	
		>>> fileInfo['cameras'] = str( ls( cameras=1) )
		>>> camList = eval(fileInfo['cameras'])
		>>> camList[0]
		# Result: frontShape #
		>>> list[0].getFocalLength()  # it's still a valid pymel class
		# Result: 35.0 #
	
	for backward compatibility it retains it's original syntax as well:
		
		>>> fileInfo( 'myKey', 'myData' )
		
	"""
	
	def __contains__(self, item):
		return item in self.keys()
		
	def __getitem__(self, item):
		return dict(self.items())[item]
		
	def __setitem__(self, item, value):
		cmds.fileInfo( item, value )
	
	def __call__(self, *args, **kwargs):
		if kwargs.get('query', kwargs.get('q', False) ):
			return self.items()
		else:
			cmds.FileInfo( *args, **kwargs )
			
	def items(self):
		res = cmds.fileInfo( query=1)
		newRes = []
		for i in range( 0, len(res), 2):
			newRes.append( (res[i], res[i+1]) )
		return newRes
		
	def keys(self):
		res = cmds.fileInfo( query=1)
		newRes = []
		for i in range( 0, len(res), 2):
			newRes.append(  res[i] )
		return newRes
			
	def values(self):
		res = cmds.fileInfo( query=1)
		newRes = []
		for i in range( 0, len(res), 2):
			newRes.append( res[i+1] )
		return newRes
	
	def pop(self, *args):
		if len(args) > 2:
			raise TypeError, 'pop expected at most 2 arguments, got %d' % len(args)
		elif len(args) < 1:
			raise TypeError, 'pop expected at least 1 arguments, got %d' % len(args)
		
		if args[0] not in self.keys():
			try:
				return args[1]
			except IndexError:
				raise KeyError, args[0]
					
		cmds.fileInfo( rm=args[0])
	
	has_key = __contains__	
fileInfo = FileInfo()
	
#-----------------------------------------------
#  Scene Class
#-----------------------------------------------

class Scene(util.Singleton):
	def __getattr__(self, obj):
		return PyNode( obj )

SCENE = Scene()


#-----------------------------------------------
#  Enhanced Commands
#-----------------------------------------------

def select(*args, **kwargs):
	"""
Modifications:
	- passing an empty list no longer causes an error. instead, the selection is simply cleared
	
	"""
	
	try:
		cmds.select(*args, **kwargs)
	except TypeError, msg:
		if args == ([],):
			cmds.select(cl=True)
		else:
			raise TypeError, msg
#select.__doc__ = mel.help('select') + select.__doc__

def move(obj, *args, **kwargs):
	"""
Modifications:
	- allows any iterable object to be passed as first argument::
		move("pSphere1", [0,1,2])
		
NOTE: this command also reorders the argument order to be more intuitive, with the object first
	"""
	if len(args) == 1 and util.isIterable(args[0]):
		args = tuple(args[0])
	args = args + (obj,)
	return cmds.move(*args, **kwargs)

def scale(obj, *args, **kwargs):
	"""
Modifications:
	- allows any iterable object to be passed as first argument::
		scale("pSphere1", [0,1,2])
		
NOTE: this command also reorders the argument order to be more intuitive, with the object first
	"""
	if len(args) == 1 and util.isIterable(args[0]):
		args = tuple(args[0])
	args = args + (obj,)
	return cmds.scale(*args, **kwargs)
	
def rotate(obj, *args, **kwargs):
	"""
Modifications:
	- allows any iterable object to be passed as first argument::
		rotate("pSphere1", [0,1,2])
		
NOTE: this command also reorders the argument order to be more intuitive, with the object first
	"""
	if len(args) == 1 and util.isIterable(args[0]):
		args = tuple(args[0])
	args = args + (obj,)
	return cmds.rotate(*args, **kwargs)
		
def connectAttr( source, destination, **kwargs ):
	"""
Maya Bug Fix: 
	- even with the 'force' flag enabled, the command would raise an error if the connection already existed. 
	
	"""
	if kwargs.get('force', False) or kwargs.get('f', False):	
		try:
			cmds.connectAttr( source, destination, **kwargs )
		except RuntimeError:
			pass
	else:
		cmds.connectAttr( source, destination, **kwargs )

def disconnectAttr( source, destination=None, **kwargs ):
	"""
Modifications:
	- If no destination is passed, all inputs and outputs will be disconnected from the attribute
	"""
	source = Attribute(source)
	if destination:
		return cmds.disconnectAttr( source, destination, **kwargs )
	else:
		for source, destination in source.outputs( connections=True, plugs=True ):
			cmds.disconnectAttr( source, destination, **kwargs )
			
		for destination, source in source.inputs( connections=True, plugs=True ):
			cmds.disconnectAttr( source, destination, **kwargs )	
		
def getAttr( attr, **kwargs ):
	"""
Maya Bug Fix:
	- maya pointlessly returned vector results as a tuple wrapped in 
		a list ( ex.  '[(1,2,3)]' ). This command unpacks the vector for you.
Modifications:
	- casts double3 datatypes to Vector
	- casts matrix datatypes to Matrix
	- when getting a multi-attr, maya would raise an error, but pymel will return a list of
	 	values for the multi-attr
	"""
	def listToMat( l ):
		return [ 	[	l[0], l[1], l[2], l[3]	],
			[	l[4], l[5], l[6], l[7]	],
			[	l[8], l[9], l[10], l[11]	],
			[	l[12], l[13], l[14], l[15] ]	]
		
	try:
		res = cmds.getAttr( attr, **kwargs)
		
		if isinstance(res, list) and len(res):
			if isinstance(res[0], tuple):
				res = res[0]
				if cmds.getAttr( attr, type=1) == 'double3':
					return Vector(list(res))
			elif cmds.getAttr( attr, type=1) == 'matrix':
				return Matrix(listToMat(res))
			
		return res
	
	# perhaps it errored because it's a multi attribute
	except RuntimeError, msg:
		attr = Attribute(attr)
		if attr.isMulti():
			return [attr[i].get() for i in range(attr.size())]
		raise RuntimeError, msg


	
# getting and setting					
def setAttr( attr, *args, **kwargs):
	"""
Modifications:
	- No need to set type, this will automatically be determined
 	- Adds support for passing a list or tuple as the second argument for datatypes such as double3.
	- When setting stringArray datatype, you no longer need to prefix the list with the number of elements - just pass a list or tuple as with other arrays
	- Added 'force' kwarg, which causes the attribute to be added if it does not exist. 
		- attribute type is based on type of value being set (if you want a float, be sure to format it as a float, e.g.  3.0 not 3)
		- currently does not support compound attributes
		- currently supported python-to-maya mappings:
		
			- float 	S{->} double
			- int		S{->} long
			- str		S{->} string
			- bool		S{->} bool
			- [float] 	S{->} doubleArray
			- [int]		S{->} Int32Array
			- [str]		S{->} stringArray
	"""
	
	if len(args) == 1:
		force = kwargs.pop('force', False)
		if not force:
			force = kwargs.pop('f', False)
			
		if util.isIterable(args[0]):
			datatype = None
			if force:
				attr = Attribute(attr)
				try:

					if isinstance( args[0][0], basestring ):
						datatype = 'stringArray'
					elif isinstance( args[0][0], int ):
						datatype = 'Int32Array'
					elif isinstance( args[0][0], float ):
						datatype = 'doubleArray'			
					else:
						raise ValueError, "pymel.setAttr: %s is not a supported type" % type(args[0][0])
											
					if not attr.exists():
						print "adding", attr, datatype
						attr.add( dt=datatype ) 
					kwargs['type'] = datatype
						
				except IndexError:
					if not attr.exists():
						raise ValueError, "pymel.setAttr: when setting 'force' keyword to create a new array attribute, you must provide an array with at least one element"  					
				except TypeError:
					raise ValueError, "pymel.setAttr: %s is not a supported type" % type(args[0])
						
			if 'type' not in kwargs:
				if not datatype:
					#print "Getting datatype", attr
					datatype = cmds.getAttr( attr, type=1)
				if not datatype:
					#print "Getting datatype", attr
					datatype = cmds.addAttr( attr, q=1, dataType=1)
				
				# set datatype for arrays
				# we could do this for all, but i'm uncertain that it needs to be 
				# done and it might cause more problems
				if datatype.endswith('Array'):
					kwargs['type'] = datatype
			
			# string arrays need the first arg to be the length of the array being set
			if kwargs.get('type',None) == 'stringArray':
				args = tuple( [len(args[0])] + args[0] )
			else:
				args = tuple(args[0])
		
		else:
			if force:
				attr = Attribute(attr)					
				if not attr.exists():
					if isinstance( args[0], basestring ):
						attr.add( dt='string' ) 
					elif isinstance( args[0], int ):
						attr.add( at='long' ) 
					elif isinstance( args[0], float ):
						attr.add( at='double' ) 
					elif isinstance( args[0], bool ):
						attr.add( at='bool' ) 
					else:
						raise TypeError, "pymel.setAttr: %s is not a supported type" % type(args[0])
									
			if isinstance(args[0],basestring):
				kwargs['type'] = 'string'
				kwargs.pop('t', None )
				
			
	#print args, kwargs
	cmds.setAttr( attr, *args, **kwargs)

def addAttr( *args, **kwargs ):
	"""
Modifications:
	- addAttr: allow python types to be passed to set -at type
			str		--> string
			float 	--> double
			int		--> long
			bool	--> bool
			Vector	--> double3
"""
	at = kwargs.pop('attributeType', kwargs.pop('at', None ))
	if at is not None:
		if at in [str, unicode]:
			kwargs['dt'] = 'string'
		else:
			try: 
				kwargs['at'] = {
					float: 'double',
					int: 'long',
					bool: 'bool',
					Vector: 'double3'
				}[at]
			except KeyError:
				kwargs['at'] = at
	return cmds.addAttr( *args, **kwargs )
		
def currentTime( *args, **kwargs ):
	"""
Modifications:
	- if no args are provided, the command returns the current time -- the equivalent of::
		cmds.currentTime(q=1)
	"""
	
	if not args and not kwargs:
		return cmds.currentTime(q=1)
	else:
		return cmds.currentTime(*args, **kwargs)

def group( *args, **kwargs ):
	"""
Modifications
	- if no objects are provided for grouping, the empty flag is automatically set
	"""
	if not args and not cmds.ls(sl=1):
		kwargs['empty'] = True
	return Transform( cmds.group(*args, **kwargs) )
	#except RuntimeError, msg:
	#	print msg
	#	if msg == 'Not enough objects or values.':
	#		kwargs['empty'] = True
	#		return Transform( cmds.group(**kwargs) )
		
def listConnections(*args, **kwargs):
	"""
Modifications:
	- returns an empty list when the result is None
	- When 'connections' flag is True, the attribute pairs are returned in a 2D-array::
		[['checker1.outColor', 'lambert1.color'], ['checker1.color1', 'fractal1.outColor']]
	- added sourceFirst keyword arg. when sourceFirst is true and connections is also true, 
		the paired list of plugs is returned in (source,destination) order instead of (thisnode,othernode) order.
		this puts the pairs in the order that disconnectAttr and connectAttr expect.
	"""
	def makePairs(l):
		res = []
		if l is None:
			return res
			
		for i in range(0, len(l),2):
			res.append( ( PyNode(l[i]), PyNode(l[i+1]) )  )
		return res
		
	if kwargs.get('connections', kwargs.get('c', False) ) :	
		
				
		if kwargs.pop('sourceFirst',False):
			source = kwargs.get('source', kwargs.get('s', True ) )
			dest = kwargs.get('destination', kwargs.get('d', True ) )

			if source:				
				if not dest:
					return [ (s, d) for d, s in makePairs( cmds.listConnections( *args,  **kwargs ) ) ]
				else:
					res = []
					kwargs.pop('destination', None)
					kwargs['d'] = False					
					res = [ (s, d) for d, s in makePairs(cmds.listConnections( *args,  **kwargs )) ]					

					kwargs.pop('source', None)
					kwargs['s'] = False
					kwargs['d'] = True
					return makePairs(cmds.listConnections( *args,  **kwargs )) + res
					
			# if dest passes through to normal method 
			
		return makePairs( cmds.listConnections( *args,  **kwargs ) )

	else:
		return map(PyNode, util.listForNone(cmds.listConnections( *args,  **kwargs )) )

def listHistory( *args, **kwargs ):
	"""
Modifications:
	- returns an empty list when the result is None
	- added a much needed 'type' filter
	"""
	
	if 'type' in kwargs:
		typ = kwargs.pop('type')
		return filter( lambda x: cmds.nodeType(x) == typ, map( PyNode, cmds.listHistory( *args,  **kwargs ) )  )
	return map(PyNode, util.listForNone(cmds.listHistory( *args,  **kwargs ) ) )

		
def listFuture( *args, **kwargs ):
	"""
Modifications:
	- returns an empty list when the result is None
	- added a much needed 'type' filter
	"""
	kwargs['future'] = True
	if 'type' in kwargs:
		typ = kwargs.pop('type')
		return filter( lambda x: cmds.nodeType(x) == typ, map( PyNode, cmds.listHistory( *args,  **kwargs ) )  )
	return map(PyNode, util.listForNone(cmds.listHistory( *args,  **kwargs )) )

		
def listRelatives( *args, **kwargs ):
	"""
Maya Bug Fix
	- allDescendents and shapes flags did not work in combination
	
Modifications:
	- returns an empty list when the result is None
	- returns wrapped classes
	"""
	
	if kwargs.get( 'allDescendents', kwargs.get('ad', False) ) and kwargs.pop( 'shapes', kwargs.pop('s', False) ):		
		kwargs['fullPath'] = True
		kwargs.pop('f', None)

		res = cmds.listRelatives( *args, **kwargs)
		if res is None:
			return
		return ls( res, shapes=1)

	if longNames:
		kwargs['fullPath'] = True
		kwargs.pop('f', None)
				
	return map(PyNode, util.listForNone(cmds.listRelatives(*args, **kwargs)))


def ls( *args, **kwargs ):
	"""
Modifications:
	- Added new keyword: 'editable' - this will return the inverse set of the readOnly flag. i.e. non-read-only nodes
	"""
	if longNames:
		kwargs['long'] = True
		kwargs.pop('l', None)
	
	if kwargs.pop('editable', False):
		allNodes = util.listForNone(cmds.ls(*args, **kwargs))
		kwargs['readOnly'] = True
		kwargs.pop('ro',True)
		roNodes = util.listForNone(cmds.ls(*args, **kwargs))
		
		# faster way?
		return map( PyNode, filter( lambda x: x not in roNodes, allNodes ) )
	
	# this has been removed because the method below
	# is 3x faster because it gets the node type along with the node list
	# unfortunately, it's still about 2x slower than cmds.ls
	#return map(PyNode, util.listForNone(cmds.ls(*args, **kwargs)))
	
	if kwargs.get( 'readOnly', kwargs.get('ro', False) ):
		# when readOnly is provided showType is ignored
		return map(PyNode, util.listForNone(cmds.ls(*args, **kwargs)))
		
	if kwargs.get( 'showType', kwargs.get('st', False) ):
		tmp = util.listForNone(cmds.ls(*args, **kwargs))
		res = []
		for i in range(0,len(tmp),2):
			res.append( PyNode( tmp[i], tmp[i+1] ) )
			res.append( tmp[i+1] )
		return res	
		
	kwargs['showType'] = True
	tmp = util.listForNone(cmds.ls(*args, **kwargs))
	res = []
	for i in range(0,len(tmp),2):
		res.append( PyNode( tmp[i], tmp[i+1] ) )
	
	return res
	
	'''
	showType = kwargs.get( 'showType', kwargs.get('st', False) )
	kwargs['showType'] = True
	kwargs.pop('st',None)	
	res = []
	if kwargs.get( 'readOnly', kwargs.get('ro', False) ):
		
		ro = cmds.ls(*args, **kwargs) # showType flag will be ignored
		
		# this was unbelievably slow
		
		kwargs.pop('readOnly',None)
		kwargs.pop('ro',None)
		all = cmds.ls(*args, **kwargs)
		for node in ro:
			try:	
				idx = all.index(node)
				all.pop(idx)
				typ = all.pop(idx+1)
				res.append( PyNode( node, typ ) ) 
				if showType:
					res.append( typ )
			except ValueError: pass
		return res
	else:
		tmp = util.listForNone(cmds.ls(*args, **kwargs))
		for i in range(0,len(tmp),2):
			typ = tmp[i+1]
			res.append( PyNode( tmp[i],  ) )	
			if showType:
				res.append( typ )
		
		return res
	'''
	
def lsThroughFilter( *args, **kwargs):
	"""
Modifications:
	- returns an empty list when the result is None
	- returns wrapped classes
	"""
	return map(PyNode, util.listForNone(cmds.lsThroughFilter(*args, **kwargs)))

	#for i in cmds.ls(*args, **kwargs):
	#	yield PyNode(i)
def listTransforms( *args, **kwargs ):
	"""
Modifications:
	- returns wrapped classes
	"""

	res = cmds.listRelatives(  cmds.ls(*args, **kwargs), p=1, path=1 )
	return map( PyNode, res, ['transform']*len(res) )

def duplicate( *args, **kwargs ):
	"""
Modifications:
	- returns wrapped classes
	"""
	return map(PyNode, cmds.duplicate( *args, **kwargs ) )

	
def instance( *args, **kwargs ):
	"""
Modifications:
	- returns wrapped classes
	"""
	return map(PyNode, cmds.instance( *args, **kwargs ) )	

'''		
def attributeInfo( *args, **kwargs ):
	"""
Modifications:
	- returns an empty list when the result is None
	- returns wrapped classes
	"""
	
	return map(PyNode, util.listForNone(cmds.attributeInfo(*args, **kwargs)))
'''

def rename( obj, newname, **kwargs):
	"""
Modifications:
	- if the full path to an object is passed as the new name, the shortname of the object will automatically be used
	"""
	
	if isinstance( newname, Dag ):
		newname = newname.shortName()
		
	return PyNode( cmds.rename( obj, newname, **kwargs ) )
	
def createNode( *args, **kwargs):
	return PyNode( cmds.createNode( *args, **kwargs ) )
			
def shadingNode( *args, **kwargs):
	return PyNode( cmds.shadingNode( *args, **kwargs ) )
				
def sets( *elements, **kwargs):
	"""The first argument must be a list of objects, a Set instance, or the name of a set."""
	try:
		elements = elements[0]
	except:
		pass
	
	#print elements
	if 'query' in kwargs or 'q' in kwargs:
		#print "query", kwargs, len(kwargs)
		if len(kwargs) == 1:
			# list of elements
			
			return set( cmds.sets( elements, **kwargs ) or [] )
		# other query
		return cmds.sets( elements, **kwargs )
		
	elif 'clear' in kwargs or 'cl' in kwargs:		
		return cmds.sets( **kwargs )
	
	
	if isinstance(elements,basestring):
		elements = cmds.sets( elements, q=True )
	#print elements, kwargs	
	nonCreationArgs = set([
				'edit', 'e',
				'isIntersecting', 'ii',
				'isMember', 'im',
				'subtract', 'sub',
				'union', 'un',
				'intersection', 'int'])
	if len( nonCreationArgs.intersection(kwargs.keys()) ):
		#print "creation"
		return cmds.sets( *elements, **kwargs )

	# Creation
	#args = _convertListArgs(args)
	#print "creation"
	return Set(cmds.sets( *elements, **kwargs ))


def joint(*args, **kwargs):
	"""
Maya Bug Fix:
	- when queried, limitSwitch*, stiffness*, and angle* flags returned lists of values instead 
		of single values. Values are now properly unpacked
	"""
	
	res = cmds.joint(*args, **kwargs)
	
	#if kwargs.pop('query',False) or kwargs.pop('q',False):

	if kwargs.get('query', kwargs.get( 'q', False)):
		args = [
		'limitSwitchX', 'lsx',
		'limitSwitchY', 'lsy',
		'limitSwitchZ', 'lsz',
		'stiffnessX', 'stx',
		'stiffnessY', 'sty',
		'stiffnessZ', 'stz',
		'angleX', 'ax',
		'angleY', 'ay',
		'angleZ', 'az'
		]
		if filter( lambda x: x in args, kwargs.keys()):
			res = res[0]
	elif res is not None:	
		res = PyNode(res)
	return res

def aimConstraint(*args, **kwargs):
	"""
Maya Bug Fix:
	- when queried, upVector, worldUpVector, and aimVector returned the name of the constraint instead of the desired values
	"""
	if 'query' in kwargs or 'q' in kwargs:
		
		attrs = [
		'upVector', 'u',
		'worldUpVector', 'wu',
		'aimVector', 'a' ]
		
		for attr in attrs:
			if attr in kwargs:
				return Vector( getAttr(args[0] + "." + attr ) )
				
			
	res = cmds.aimConstraint(*args, **kwargs)
	
	if res and 'query' not in kwargs and 'q' not in kwargs:
		try:
			res = PyNode( res[0] )
		except: pass
	return res

def normalConstraint(*args, **kwargs):
	"""
Maya Bug Fix:
	- when queried, upVector, worldUpVector, and aimVector returned the name of the constraint instead of the desired values
	"""
	if 'query' in kwargs or 'q' in kwargs:
		
		attrs = [
		'upVector', 'u',
		'worldUpVector', 'wu',
		'aimVector', 'a' ]
		
		for attr in attrs:
			if attr in kwargs:
				return Vector( getAttr(args[0] + "." + attr ) )
				
			
	res = cmds.normalConstraint(*args, **kwargs)
	
	if res and 'query' not in kwargs and 'q' not in kwargs:
		try:
			res = PyNode( res[0] )
		except: pass
	return res

def pointLight(*args,**kwargs):
	"""
Maya Bug Fix:
	- name flag was ignored
	"""	
	if kwargs.get('query', kwargs.get('q', False)) or kwargs.get('edit', kwargs.get('e', False)):
		return cmds.pointLight(*args, **kwargs)
	
	else:	
		name = kwargs.pop('name', kwargs.pop('n', False ) )
		if name:
			tmp = cmds.pointLight(*args, **kwargs)
			tmp = cmds.rename( cmds.listRelatives( tmp, parent=1)[0], name)
			return PyNode( cmds.listRelatives( tmp, shapes=1)[0], 'pointLight' )
	
	return PyNode( cmds.pointLight(*args, **kwargs), 'pointLight'  )

def spotLight(*args,**kwargs):
	"""
Maya Bug Fix:
	- name flag was ignored
	"""	
	if kwargs.get('query', kwargs.get('q', False)) or kwargs.get('edit', kwargs.get('e', False)):
		return cmds.spotLight(*args, **kwargs)
	
	else:	
		name = kwargs.pop('name', kwargs.pop('n', False ) )
		if name:
			tmp = cmds.spotLight(*args, **kwargs)
			tmp = cmds.rename( cmds.listRelatives( tmp, parent=1)[0], name)
			return PyNode( cmds.listRelatives( tmp, shapes=1)[0], 'spotLight' )
	
	return PyNode( cmds.spotLight(*args, **kwargs), 'spotLight'  )

def directionalLight(*args,**kwargs):
	"""
Maya Bug Fix:
	- name flag was ignored
	"""	
	
	if kwargs.get('query', kwargs.get('q', False)) or kwargs.get('edit', kwargs.get('e', False)):
		return cmds.directionalLight(*args, **kwargs)
	
	else:	
		name = kwargs.pop('name', kwargs.pop('n', False ) )
		if name:
			tmp = cmds.directionalLight(*args, **kwargs)
			tmp = cmds.rename( cmds.listRelatives( tmp, parent=1)[0], name)
			return PyNode( cmds.listRelatives( tmp, shapes=1)[0], 'directionalLight' )
	
	return PyNode( cmds.directionalLight(*args, **kwargs), 'directionalLight'  )

def ambientLight(*args,**kwargs):
	"""
Maya Bug Fix:
	- name flag was ignored
	"""	
	if kwargs.get('query', kwargs.get('q', False)) or kwargs.get('edit', kwargs.get('e', False)):
		return cmds.ambientLight(*args, **kwargs)
	
	else:	
		name = kwargs.pop('name', kwargs.pop('n', False ) )
		if name:
			tmp = cmds.ambientLight(*args, **kwargs)
			tmp = cmds.rename( cmds.listRelatives( tmp, parent=1)[0], name)
			return PyNode( cmds.listRelatives( tmp, shapes=1)[0], 'ambientLight' )
	
	return PyNode( cmds.ambientLight(*args, **kwargs), 'ambientLight'  )
								
def spaceLocator(*args, **kwargs):
	"""
Modifications:
	- returns a locator instead of a list with a single locator
	"""
	res = cmds.spaceLocator(**kwargs)
	try:
		return Transform(res[0])
	except:
		return res
	
def instancer(*args, **kwargs):
	"""
Maya Bug Fix:
	- name of newly created instancer was not returned
	"""	
	if kwargs.get('query', kwargs.get('q',False)):
		return cmds.instancer(*args, **kwargs)
	if kwargs.get('edit', kwargs.get('e',False)):
		cmds.instancer(*args, **kwargs)
		return PyNode( args[0], 'instancer' )
	else:
		instancers = cmds.ls(type='instancer')
		cmds.instancer(*args, **kwargs)
		return PyNode( list( set(cmds.ls(type='instancer')).difference( instancers ) )[0], 'instancer' )

	


scriptTableCmds = {}

def scriptTable(*args, **kwargs):
	"""
Maya Bug Fix:
	- fixed getCellCmd to work with python functions, previously only worked with mel callbacks
		IMPORTANT: you cannot use the print statement within the getCellCmd callback function or your values will not be returned to the table
	"""
	cb = kwargs.pop('getCellCmd', kwargs.pop('gcc',False) )
	if cb:
		if hasattr(cb, '__call__'):		
			uiName = cmds.scriptTable( *args, **kwargs )
			procName = 'getCellMel%d' % len(scriptTableCmds.keys())
			procCmd = "global proc string %s( int $row, int $column ){return python(\"pymel.scriptTableCmds['%s'](\" + $row + \",\" + $column + \")\");}" %  (procName,uiName) 
			#print procCmd
			mm.eval( procCmd )			
			scriptTableCmds[uiName] = cb
			
			# create a scriptJob to clean up the dictionary of functions
			popCmd = "python(\"scriptTableCmds.pop('%s',None)\")" % uiName 
			#print popCmd
			cmds.scriptJob( uiDeleted=(uiName, "python(\"pymel.scriptTableCmds.pop('%s',None)\")" % uiName ) )

			return cmds.scriptTable( uiName, e=1, getCellCmd=procName )
		else:
			kwargs['getCellCmd'] = cb	
	
	cmds.scriptTable( *args, **kwargs )

	
#--------------------------
# New Commands
#--------------------------

def sceneName():
	#return Path(cmds.file( q=1, sn=1))
	return Path( OpenMaya.MFileIO.currentFile() )
def getCurrentTime():
	"""get the current time as a float"""
	return cmds.currentTime(q=1)
	
def setCurrentTime( time ):
	"""set the current time """
	return cmds.currentTime(time)

def selected( **kwargs ):
	"""ls -sl"""
	kwargs['sl'] = 1
	return ls( **kwargs )

def createSurfaceShader( shadertype, name=None ):
	classification = getClassification( shadertype )[0].split(':')
	#print classification
	newShader = None
	if 'shader/surface' in classification:		
		if 'rendernode/mentalray/material' in classification:
			newShader = Node(mel.mrCreateCustomNode( "-asShader", "", shadertype))
		else:
			newShader = Node(mel.renderCreateNode( "-asShader", "surfaceShader", shadertype, "", 0, 0, 0, 1, 0, ""))
		print "new", newShader
	else:
		raise TypeError, "%s is not a valid surface shader type. shader must be classified as 'shader/surface'" % shadertype
	if name:
		newShader = newShader.rename(name)
		sg = newShader.shadingGroups()[0]
		sg.rename( name + 'SG')
	return newShader

#-----------------------------------------------
#  File Classes
#-----------------------------------------------
	
class Path(pathClass):
	"""A basic Maya file class. it gets most of its power from the path class written by Jason Orendorff.
	see path.py for more documentation."""
	def __repr__(self):
		return "%s('%s')" % (self.__class__.__name__, self)
	def writable(self):
		return cmds.file( self, q=1, writable=1 )
	def type(self):
		return cmds.file( self, q=1, type=1 )
		
class Reference(Path):
	"""A class for manipulating references which inherits Path and path.  you can create an 
	instance by supplying the path to a reference file, its namespace, or its reference node to the 
	appropriate keyword. The namespace and reference node of the reference can be retreived via 
	the namespace and refNode properties. The namespace property can also be used to change the namespace
	of the reference. 
	
	Use listRefences command to return a list of references as instances of the Reference class.
	
	It is important to note that instances of this class will have their copy number stripped off
	and stored in an internal variable upon creation.  This is to maintain compatibility with the numerous methods
	inherited from the path class which requires a real file path. When calling built-in methods of Reference, 
	the path will automatically be suffixed with the copy number before being passed to maya commands, thus ensuring 
	the proper results in maya as well. 
	 """
	
	def __new__(cls, path=None, namespace=None, refnode=None):
		def create(path):
			def splitCopyNumber(path):
				"""Return a tuple with the path and the copy number. Second element will be None if no copy number"""
				buf = path.split('{')
				try:
					return ( buf[0], int(buf[1][:-1]) )
				except:
					return (path, None)
					
			path, copyNumber = splitCopyNumber(path)
			self = Path.__new__(cls, path)
			self._copyNumber = copyNumber
			return self
			
		if path:
			return create(path)
		if namespace:
			for path in map( Reference, cmds.file( q=1, reference=1) ):
				 if path.namespace == namespace:
					return create(path)
			raise ValueError, "Namespace '%s' does not match any found in scene" % namespace
		if refnode:
			path = cmds.referenceQuery( refnode, filename=1 )
			return create(path)
		raise ValueError, "Must supply at least one argument"	

	def subReferences(self):
		namespace = self.namespace + ':'
		res = {}
		try:
			for x in cmds.file( self, q=1, reference=1):
				res[namespace + cmds.file( x, q=1, namespace=1)] = pymel.core.Reference(x)
		except: pass
		return res	
		
		
	def namespaceExists(self):
		return cmds.namespace(ex=self.namespace)
		
	def withCopyNumber(self):
		"""return this path with the copy number at the end"""
		if self._copyNumber is not None:
			return Path( '%s{%d}' % (self, self._copyNumber) )
		return self
			
	def importContents(self):
		"""file -importReference """
		return cmds.file( self.withCopyNumber(), importReference=1 )
	def	remove(self):
		"""file -removeReference """
		return cmds.file( self.withCopyNumber(), removeReference=1 )
	def	unload(self):
		"""file -unloadReference """
		return cmds.file( self.withCopyNumber(), unloadReference=1 )	
	def	clean(self):
		"""file -cleanReference """
		return cmds.file( self.withCopyNumber(), cleanReference=1 )
	def	lock(self):
		"""file -lockReference """
		return cmds.file( self.withCopyNumber(), lockReference=1 )
	
	def isDeferred(self):
		"""file -q -deferReference """
		return cmds.file( self.withCopyNumber(), q=1, deferReference=1 )
	def isLoaded(self):
		return not cmds.file( self.withCopyNumber(), q=1, deferReference=1 )
	
	def nodes(self):
		"""referenceQuery -nodes """
		return map( PyNode, cmds.referenceQuery( self.withCopyNumber(), nodes=1 ) )
	def copyNumberList(self):
		"""returns a list of all the copy numbers of this file"""
		return cmds.file( self, q=1, copyNumberList=1 )
	def selectAll(self):
		"""file -selectAll"""
		return cmds.file( self.withCopyNumber(), selectAll=1 )
			
	def _getNamespace(self):
		return cmds.file( self.withCopyNumber(), q=1, ns=1)
	def _setNamespace(self, namespace):
		return cmds.file( self.withCopyNumber(), e=1, ns=namespace)	
	namespace = property( _getNamespace, _setNamespace )

	def _getRefNode(self):
		return Node(cmds.referenceQuery( self.withCopyNumber(), referenceNode=1 ))	
	refNode = util.cacheProperty( _getRefNode, '_refNode')


#--------------------------
# Object Wrapper Classes
#--------------------------

class _BaseObj(unicode):
	def __repr__(self):
		return u"%s('%s')" % (self.__class__.__name__, self)

	#def __unicode__(self):
	#	return u"%s" % self

	def __getattr__(self, attr):
		if attr.startswith('__') and attr.endswith('__'):
			return super(_BaseObj, self).__getattr__(attr)
			
		return Attribute( '%s.%s' % (self, attr) )
		
		#raise AttributeError, 'attribute does not exist %s' % attr

	def __setattr__(self, attr, val):
		if attr.startswith('_'):
			return setAttr( '%s.%s' % (self, attr[1:]), val )			
		return setAttr( '%s.%s' % (self, attr), val )

	def stripNamespace(self, levels=0):
		"""
		Returns a new instance of the object with its namespace removed.  The calling instance is unaffected.
		The optional levels keyword specifies how many levels of cascading namespaces to strip, starting with the topmost (leftmost).
		The default is 0 which will remove all namespaces.
		"""
		
		nodes = []
		for x in self.split('|'):
			y = x.split('.')
			z = y[0].split(':')
			if levels:
				y[0] = ':'.join( z[min(len(z)-1,levels):] )
	
			else:
				y[0] = z[-1]
			nodes.append( '.'.join( y ) )
		return self.__class__( '|'.join( nodes) )

	def swapNamespace(self, prefix):
		"""Returns a new instance of the object with its current namespace replaced with the provided one.  
		The calling instance is unaffected."""	
		return Node.addPrefix( self.stripNamespace(), prefix+':' )
			
	def namespaceList(self):
		"""Useful for cascading references.  Returns all of the namespaces of the calling object as a list"""
		return self.lstrip('|').rstrip('|').split('|')[-1].split(':')[:-1]
			
	def namespace(self):
		"""Returns the namespace of the object with trailing colon included"""
		return ':'.join(self.namespaceList()) + ':'
		
	def addPrefix(self, prefix):
		'addPrefixToName'
		name = self
		leadingSlash = False
		if name.startswith('|'):
			name = name[1:]
			leadingSlash = True
		name = self.__class__( '|'.join( map( lambda x: prefix+x, name.split('|') ) ) )
		if leadingSlash:
			name = '|' + name
		return self.__class__( name )
				
						
	def attr(self, attr):
		"""access to attribute of a node. returns an instance of the Attribute class for the 
		given attribute."""
		return Attribute( '%s.%s' % (self, attr) )
				
	def objExists(self):
		return cmds.objExists( self )
		
	def nodeType(self):
		return cmds.nodeType( self )

	def select(self, **kwargs):
		forbiddenKeys = ['all', 'allDependencyNodes', 'adn', '-allDagObjects' 'ado', 'clear', 'cl']
		for key in forbiddenKeys:
			if key in kwargs:
				raise TypeError, "'%s' is an inappropriate keyword argument for object-oriented implementation of this command" % key
		
		return cmds.select( self, **kwargs )	

	def deselect( self ):
		self.select( deselect=1 )
	
	def listConnections(self, **kwargs):
		return listConnections( self, **kwargs)
		
	def connections(self, **kwargs):
		"""listConnections"""
		return listConnections( self, **kwargs)

	def listHistory(self, **kwargs):
		"""listHistory"""
		return listHistory( self, **kwargs)
		
	def history(self, **kwargs):
		"""listHistory"""
		return listHistory( self, **kwargs)

	def listFuture(self, **kwargs):
		"""listHistory -future 1"""
		return listFuture( self, **kwargs)
				
	def future(self, **kwargs):
		"""listHistory -future 1"""
		return listFuture( self, **kwargs)

class ComponentArray(object):
	def __init__(self, name):
		self._name = name
		self._iterIndex = 0
		self._node = self.node()
		
	def __str__(self):
		return self._name
		
	def __repr__(self):
		return "ComponentArray('%s')" % self
	
	#def __len__(self):
	#	return 0
		
	def __iter__(self):
		"""iterator for multi-attributes
		
			>>> for attr in SCENE.Nexus1.attrInfo(multi=1)[0]: print attr
			
		"""
		return self
				
	def next(self):
		"""iterator for multi-attributes
		
			>>> for attr in SCENE.Nexus1.attrInfo(multi=1)[0]: print attr
			
		"""
		if self._iterIndex >= len(self):
			raise StopIteration
		else:						
			new = self[ self._iterIndex ]
			self._iterIndex += 1
			return new
			
	def __getitem__(self, item):
		
		def formatSlice(item):
			step = item.step
			if step is not None:
				return '%s:%s:%s' % ( item.start, item.stop, step) 
			else:
				return '%s:%s' % ( item.start, item.stop ) 
		
		'''	
		if isinstance( item, tuple ):			
			return [ Component('%s[%s]' % (self, formatSlice(x)) ) for x in  item ]
			
		elif isinstance( item, slice ):
			return Component('%s[%s]' % (self, formatSlice(item) ) )

		else:
			return Component('%s[%s]' % (self, item) )
		'''
		if isinstance( item, tuple ):			
			return [ self.returnClass( self._node, formatSlice(x) ) for x in  item ]
			
		elif isinstance( item, slice ):
			return self.returnClass( self._node, formatSlice(item) )

		else:
			return self.returnClass( self._node, item )


	def plugNode(self):
		'plugNode'
		return PyNode( str(self).split('.')[0])
				
	def plugAttr(self):
		"""plugAttr"""
		return '.'.join(str(self).split('.')[1:])

	node = plugNode
	
class FaceArray(ComponentArray):
	def __init__(self, name):
		ComponentArray.__init__(self, name)
		self.returnClass = Face
		
	def __len__(self):
		return cmds.polyEvaluate(self.node(), face=True)

class EdgeArray(ComponentArray):
	def __init__(self, name):
		ComponentArray.__init__(self, name)
		self.returnClass = Edge
	def __len__(self):
		return cmds.polyEvaluate(self.node(), edge=True)

class VertexArray(ComponentArray):
	def __init__(self, name):
		ComponentArray.__init__(self, name)
		self.returnClass = Vertex
		
	def __len__(self):
		return cmds.polyEvaluate(self.node(), vertex=True)
				
class Component(object):
	def __init__(self, node, item):
		self._item = item
		self._node = node
				
	def __repr__(self):
		return "%s('%s')" % (self.__class__.__name__, self)
		
	def node(self):
		'plugNode'
		return self._node
	
	def item(self):
		return self._item	
		
	def move( self, *args, **kwargs ):
		return move( self, *args, **kwargs )
	def scale( self, *args, **kwargs ):
		return scale( self, *args, **kwargs )	
	def rotate( self, *args, **kwargs ):
		return rotate( self, *args, **kwargs )

class Face(Component):
	def __str__(self):
		return '%s.f[%s]' % (self._node, self._item)

	def _getFaceNormal(self):
		return Vector( map( float, cmds.polyInfo( self._node, fn=1 )[self._item].split()[2:] ))		
	normal = property(_getFaceNormal)
	
	def _getEdges(self):
		return map( self._node.e.__getitem__, cmds.polyInfo( str(self), faceToEdge=1)[0].split()[2:] )		
	edges = property(_getEdges)
	
	def _getVertices(self):
		return map( self._node.vtx.__getitem__, cmds.polyInfo( str(self), faceToVertex=1)[0].split()[2:] )		
	vertices = property(_getVertices)
	
class Edge(Component):
	def __str__(self):
		return '%s.e[%s]' % (self._node, self._item)
		
	def _getFaces(self):
		return map( self._node.e.__getitem__, cmds.polyInfo( str(self), edgeToFace=1)[0].split()[2:] )		
	faces = property(_getFaces)
	
class Vertex(Component):
	def __str__(self):
		return '%s.vtx[%s]' % (self._node, self._item)
		
	def _getEdges(self):
		return map( self._node.e.__getitem__, cmds.polyInfo( str(self), vertexToEdge=1)[0].split()[2:] )		
	edges = property(_getEdges)
	
	def _getFaces(self):
		return map( self._node.e.__getitem__, cmds.polyInfo( str(self), vertexToFace=1)[0].split()[2:] )		
	faces = property(_getFaces)
	
				
class Attribute(_BaseObj):
	"""
	Attributes
	==========
	
	The Attribute class is your one-stop shop for all attribute related functions. Modifying attributes follows a fairly
	simple pattern:  L{setAttr} becomes L{set<Attribute.set>}, L{getAttr} becomes L{get<Attribute.get>}, L{connectAttr}
	becomes L{connect<Attribute.connect>} and so on.  
	
	Accessing Attributes
	--------------------
	Most of the time, you will access instances of the Attribute class via one of the Node classes. This example demonstrates
	that the Attribute class like the L{Node} classes are based on a unicode string, and so when printed will 
	
		>>> s = polySphere()[0]
		>>> if s.visibility.isKeyable() and not s.visibility.isLocked():
		>>> 	s.visibility = True
		>>> 	s.visibility.lock()
		
		>>> print s.v.type()      # shortnames also work	
		bool
	
	Note that when the attribute is created there is currently no check for whether or not the attribute exists, just as there is 
	no check when creating instances of Node classes. This is both for speed and also because it can be useful to get a string
	representation of an attribute before it exists. 

	Getting Attribute Values
	------------------------
	To get an attribute, you use the L{'get'<Attribute.get>} method. Keep in mind that, where applicable, the values returned will 
	be cast to pymel classes. This example shows that rotation (along with translation and scale) will be returned as L{Vector}.
	
		>>> rot = s.rotate.get()
		>>> print rot
		[0.0, 0.0, 0.0]
		>>> print type(rot) # rotation is returned as a vector class
		<class 'pymel.vector.Vector'>

	Setting Attributes Values
	-------------------------
	there are several ways to set attributes in pymel.  maybe there's too many....
	
		>>> s.rotate.set([4,5,6])   # you can pass triples as a list
		>>> s.rotate.set(4,5,6)     # or not	
		>>> s.rotate = [4,5,6]      # my personal favorite

	Connecting Attributes
	---------------------
	Since the Attribute class inherits the builtin string, you can just pass the Attribute to the L{connect} method. The string formatting
	is handled for you.
				
		>>> s.rotateX.connect( s.rotateY )
	
	there are also handy operators for L{connect<Attribute.__rshift__>} and L{disconnect<Attribute.__ne__>}

		>>> c = polyCube()[0]		
		>>> s.tx >> c.tx	# connect
		>>> s.tx <> c.tx	# disconnect
			
	Avoiding Clashes between Attributes and Class Methods
	-----------------------------------------------------
	All of the examples so far have shown the shorthand syntax for accessing an attribute. The shorthand syntax has the most readability, 
	but it has the drawaback that if the attribute that you wish to acess has the same name as one of the class methods of the node
	then an error will be raised. There is an alternatives which will avoid this pitfall.
			
	attr Method
	~~~~~~~~~~~
	The attr method is the safest way the access an attribute, and can even be used to access attributes that conflict with 
	python's own special methods, and which would fail using shorthand syntax. This method is passed a string which
	is the name of the attribute to be accessed. This gives it the added advantage of being capable of recieving attributes which 
	are determine at runtime: 
	
		>>> s.addAttr('__init__')
		>>> s.attr('__init__').set( .5 )
		>>> s.attr('translate').isLocked()  # this succeeds
		>>> for axis in ['X', 'Y', 'Z']: s.attr( 'translate' + axis ).lock()	
	"""
	attrItemReg = re.compile( '.*\[(\d+)\]$')
	
	#def __repr__(self):
	#	return "Attribute('%s')" % self
			
	def __init__(self, attrName):
		if '.' not in attrName:
			raise TypeError, "%s: Attributes must include the node and the attribute. e.g. 'nodeName.attributeName' " % self
		self.__dict__['_multiattrIndex'] = 0
		
	def __getitem__(self, item):
	   return Attribute('%s[%s]' % (self, item) )

	'''
	def __iter__(self):
		"""iterator for multi-attributes
		
			>>> for attr in SCENE.Nexus1.attrInfo(multi=1)[0]: print attr
			
		"""
		if self.isMulti():
			return self
		else:
			raise TypeError, "%s is not a multi-attribute and cannot be iterated over" % self
			
	def next(self):
		"""iterator for multi-attributes
		
			>>> for attr in SCENE.Nexus1.attrInfo(multi=1)[0]: print attr
			
		"""
		if self.__dict__['_multiattrIndex'] >= self.size():
			raise StopIteration
		else:			
			attr = Attribute('%s[%s]' % (self, self.__dict__['_multiattrIndex']) )
			self.__dict__['_multiattrIndex'] += 1
			return attr
	'''		
							
	def plugNode(self):
		'plugNode'
		return PyNode( str(self).split('.')[0])
				
	def plugAttr(self):
		"""plugAttr"""
		return '.'.join(str(self).split('.')[1:])

	node = plugNode
	
	def item(self):
		try: 
			return int(Attribute.attrItemReg.match(self).group(1))
		except: return None
			
	# getting and setting					
	set = setAttr			
	get = getAttr
		
	
	
	#----------------------
	# Connections
	#----------------------	
					
	def isConnected(self, *args, **kwargs):
		return cmds.isConnected(self, *args, **kwargs)
	
	'''			
	def __irshift__(self, other):
		"""operator for 'isConnected'
			sphere.tx >>= box.tx
		""" 
		print self, other, cmds.isConnected(self, other)
		return cmds.isConnected(self, other)
	'''	

	connect = connectAttr
		
	def __rshift__(self, other):
		"""operator for 'connectAttr'
			sphere.tx >> box.tx
		""" 
		return connectAttr( self, other, force=True )
				
	disconnect = disconnectAttr

	def __ne__(self, other):
		"""operator for 'disconnectAttr'
			sphere.tx <> box.tx
		""" 
		return cmds.disconnectAttr( self, other )
				
	def inputs(self, **kwargs):
		'listConnections -source 1 -destination 0'
		kwargs['source'] = True
		kwargs.pop('s', None )
		kwargs['destination'] = False
		kwargs.pop('d', None )
		
		return listConnections(self, **kwargs)
	
	def outputs(self, **kwargs):
		'listConnections -source 0 -destination 1'
		kwargs['source'] = False
		kwargs.pop('s', None )
		kwargs['destination'] = True
		kwargs.pop('d', None )
		
		return listConnections(self, **kwargs)
	
	def insertInput(self, node, nodeOutAttr, nodeInAttr ):
		"""connect the passed node.outAttr to this attribute and reconnect
		any pre-existing connection into node.inAttr.  if there is no
		pre-existing connection, this method works just like connectAttr. 
		
		for example, for two nodes with the connection::		
			a.out-->b.in
			
		running this command::
			b.insertInput( 'c', 'out', 'in' )
			
		causes the new connection order (assuming 'c' is a node with 'in' and 'out' attributes)::			
			a.out-->c.in
			c.out-->b.in
		"""
		inputs = self.inputs(plugs=1)
		self.connect( node + '.' + nodeOutAttr, force=1 )
		if inputs:
			inputs[0].connect( node + '.' + nodeInAttr )

	#----------------------
	# Modification
	#----------------------
	
	def alias(self, **kwargs):
		"""aliasAttr"""
		return cmds.aliasAttr( self, **kwargs )	
							
	def add( self, **kwargs):	
		kwargs['longName'] = self.plugAttr()
		kwargs.pop('ln', None )
		return cmds.addAttr( self.node(), **kwargs )	
					
	def delete(self):
		"""deleteAttr"""
		return cmds.deleteAttr( self )
	
	def remove( self, **kwargs):
		'removeMultiInstance'
		#kwargs['break'] = True
		return cmds.removeMultiInstance( self, **kwargs )
		
	# Edge, Vertex, CV Methods
	def getTranslation( self, **kwargs ):
		"""xform -translation"""
		kwargs['translation'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )
		
	#----------------------
	# Info Methods
	#----------------------
	
	def isDirty(self, **kwargs):
		return cmds.isDirty(self, **kwargs)
		
	def affects( self, **kwargs ):
		return map( lambda x: Attribute( '%s.%s' % ( self.node(), x )),
			cmds.affects( self.plugAttr(), self.node()  ) )

	def affected( self, **kwargs ):
		return map( lambda x: Attribute( '%s.%s' % ( self.node(), x )),
			cmds.affects( self.plugAttr(), self.node(), by=True  ))
				
	# getAttr info methods
	def type(self):
		"getAttr -type"
		return cmds.getAttr(self, type=True)
		
	def isKeyable(self):
		"getAttr -keyable"
		return cmds.getAttr(self, keyable=True)
			
	def size(self):
		"getAttr -size"
		return cmds.getAttr(self, size=True)	
	
	def isLocked(self):
		"getAttr -lock"
		return cmds.getAttr(self, lock=True)	

	def isSettable(self):
		"getAttr -settable"
		return cmds.getAttr(self, settable=True)

	def isCaching(self):
		"getAttr -caching"
		return cmds.getAttr(self, caching=True)
		
	def isInChannelBox(self):
		"getAttr -channelBox"
		return cmds.getAttr(self, channelBox=True)	
		
	# setAttr property methods
	def setKeyable(self, state):
		"setAttr -keyable"
		return cmds.setAttr(self, keyable=state)
			
	def setLocked(self, state):
		"setAttr -locked"
		return cmds.setAttr(self, lock=state)
		
	def lock(self):
		"setAttr -locked 1"
		return cmds.setAttr(self, lock=True)
		
	def unlock(self):
		"setAttr -locked 0"
		return cmds.setAttr(self, lock=False)
				
	def setCaching(self, state):
		"setAttr -caching"
		return cmds.setAttr(self, caching=state)
				
	def showInChannelBox(self, state):
		"setAttr -channelBox"
		return cmds.setAttr(self, channelBox=state)	
	
	# attributeQuery info methods
	def isHidden(self):
		"attributeQuery -hidden"
		return cmds.attributeQuery(self.plugAttr(), node=self.node(), hidden=True)
		
	def isConnectable(self):
		"attributeQuery -connectable"
		return cmds.attributeQuery(self.plugAttr(), node=self.node(), connectable=True)	

	def isMulti(self):
		"attributeQuery -multi"
		return cmds.attributeQuery(self.plugAttr(), node=self.node(), multi=True)	
	
	def exists(self):
		"attributeQuery -exists"
		try:
			return cmds.attributeQuery(self.plugAttr(), node=self.node(), exists=True)	
		except TypeError:
			return False
			
	def longName(self):
		"attributeQuery -longName"
		return cmds.attributeQuery(self.plugAttr(), node=self.node(), longName=True)
		
	def shortName(self):
		"attributeQuery -shortName"
		return cmds.attributeQuery(self.plugAttr(), node=self.node(), shortName=True)
			
	def getSoftMin(self):
		"""attributeQuery -softMin
			Returns None if softMin does not exist."""
		if cmds.attributeQuery(self.plugAttr(), node=self.node(), softMinExists=True):
			return cmds.attributeQuery(self.plugAttr(), node=self.node(), softMin=True)[0]	
			
	def getSoftMax(self):
		"""attributeQuery -softMax
			Returns None if softMax does not exist."""
		if cmds.attributeQuery(self.plugAttr(), node=self.node(), softMaxExists=True):
			return cmds.attributeQuery(self.plugAttr(), node=self.node(), softMax=True)[0]
	
	def getMin(self):
		"""attributeQuery -min
			Returns None if min does not exist."""
		if cmds.attributeQuery(self.plugAttr(), node=self.node(), minExists=True):
			return cmds.attributeQuery(self.plugAttr(), node=self.node(), min=True)[0]
			
	def getMax(self):
		"""attributeQuery -max
			Returns None if max does not exist."""
		if cmds.attributeQuery(self.plugAttr(), node=self.node(), maxExists=True):
			return cmds.attributeQuery(self.plugAttr(), node=self.node(), max=True)[0]
	
	def getSoftRange(self):
		"""attributeQuery -softRange
			returns a two-element list containing softMin and softMax. if the attribute does not have
			a softMin or softMax the corresponding element in the list will be set to None."""
		softRange = []
		softRange.append( self.getSoftMin() )
		softRange.append( self.getSoftMax() )
		return softRange
	
			
	def getRange(self):
		"""attributeQuery -range
			returns a two-element list containing min and max. if the attribute does not have
			a softMin or softMax the corresponding element will be set to None."""
		range = []
		range.append( self.getMin() )
		range.append( self.getMax() )
		return range
	
	def setMin(self, newMin):
		self.setRange(newMin, 'default')
		
	def setMax(self, newMax):
		self.setRange('default', newMax)

	def setMin(self, newMin):
		self.setSoftRange(newMin, 'default')
		
	def setSoftMax(self, newMax):
		self.setSoftRange('default', newMax)
				
	def setRange(self, *args):
		"""provide a min and max value as a two-element tuple or list, or as two arguments to the
		method. To remove a limit, provide a None value.  for example:
		
			>>> s = polyCube()[0]
			>>> s.addAttr( 'new' )
			>>> s.new.setRange( -2, None ) #sets just the min to -2 and removes the max limit
			>>> s.new.setMax( 3 ) # sets just the max value and leaves the min at its previous default 
			>>> s.new.getRange()
			[-2.0, 3.0 ]
			
		"""
		
		self._setRange('hard', *args)
		
	def setSoftRange(self, *args):
		self._setRange('soft', *args)	
		
	def _setRange(self, limitType, *args):
		
		if len(args)==2:
			newMin = args[0]
			newMax = args[1]
		
		if len(args)==1:
			try:
				newMin = args[0][0]
				newMax = args[0][1]
			except:	
				raise TypeError, "Please provide a min and max value as a two-element tuple or list, or as two arguments to the method. To ignore a limit, provide a None value."

				
		# first find out what connections are going into and out of the object
		ins = self.inputs(p=1)
		outs = self.outputs(p=1)

		# get the current value of the attr
		val = self.get()

		# break the connections if they exist
		self.disconnect()

		#now tokenize $objectAttr in order to get it's individual parts
		obj = self.node()
		attr = self.plugAttr()

		# re-create the attribute with the new min/max
		kwargs = {}
		kwargs['at'] = self.type()
		kwargs['ln'] = attr
		
		# MIN
		# if 'default' is passed a value, we retain the current value
		if newMin == 'default':
			currMin = self.getMin()
			currSoftMin = self.getSoftMin()
			if currMin is not None:
				kwargs['min'] = currMin
			elif currSoftMin is not None:
				kwargs['smn'] = currSoftMin	
				
		elif newMin is not None:
			if limitType == 'hard':
				kwargs['min'] = newMin
			else:
				kwargs['smn'] = newMin
				
		# MAX	
		# if 'default' is passed a value, we retain the current value
		if newMax == 'default':
			currMax = self.getMax()
			currSoftMax = self.getSoftMin()
			if currMax is not None:
				kwargs['max'] = currMax
			elif currSoftMax is not None:
				kwargs['smx'] = currSoftMax	
				
		elif newMax is not None:
			if limitType == 'hard':
				kwargs['max'] = newMax
			else:
				kwargs['smx'] = newMax
		
		# delete the attribute
		self.delete()				
		cmds.addAttr( obj, **kwargs )

		# set the value to be what it used to be
		self.set(val);

		# remake the connections
		for conn in ins:
			conn >> self
			
		for conn in outs:
			self >> outs


	def getChildren(self):
		"""attributeQuery -listChildren"""
		res = cmds.attributeQuery(self.plugAttr(), node=self.node(), listChildren=True)
		if res is None:
			return []
		return res

	def getSiblings(self):
		"""attributeQuery -listSiblings"""
		res = cmds.attributeQuery(self.plugAttr(), node=self.node(), listSiblings=True)
		if res is None:
			return []
		return res
		
	def getParent(self):
		"""attributeQuery -listParent"""	
		
		if self.count('.') > 1:
			return Attribute('.'.join(self.split('.')[:-1]))
		try:
			return cmds.attributeQuery(self.plugAttr(), node=self.node(), listParent=True)[0]
		except TypeError:
			return None
	
		
'''
class NodeAttrRelay(unicode):
	
	def __getattr__(self, attr):
		if attr.startswith('_'):
			return getAttr( '%s.%s' % (self, attr[1:]) )		
		return getAttr( '%s.%s' % (self, attr) )
	
	def __setattr__(self, attr, val):
		if attr.startswith('_'):
			return setAttr( '%s.%s' % (self, attr[1:]), val )			
		return setAttr( '%s.%s' % (self, attr), val )	
'''

class Node( _BaseObj ):
	#-------------------------------
	#	Name Info and Manipulation
	#-------------------------------
	
	def node(self):
		"""for compatibility with Attribute class"""
		return self
		

	#--------------------------
	#	Modification
	#--------------------------
		
	def lock( self, **kwargs ):
		'lockNode -lock 1'
		kwargs['lock'] = True
		kwargs.pop('l',None)
		return cmds.lockNode( self, **kwargs)
		
	def unlock( self, **kwargs ):
		'lockNode -lock 0'
		kwargs['lock'] = False
		kwargs.pop('l',None)
		return cmds.lockNode( self, **kwargs)
		
	def listAttr( self, **kwargs):
		"listAttr"
		return map( lambda x: PyNode( '%s.%s' % (self, x) ), util.listForNone(cmds.listAttr(self, **kwargs)))

	def attrInfo( self, **kwargs):
		"attributeInfo"
		return map( lambda x: PyNode( '%s.%s' % (self, x) ), util.listForNone(cmds.attributeInfo(self, **kwargs)))
			
	def cast( self, swapNode, **kwargs):
		"""nodeCast"""
		return cmds.nodeCast( self, swapNode, *kwargs )
	
	rename = rename
	
	duplicate = duplicate
	
	#--------------------------
	#	Presets
	#--------------------------
	
	def savePreset(self, presetName, custom=None, attributes=[]):
		
		kwargs = {'save':True}
		if attributes:
			kwargs['attributes'] = ' '.join(attributes)
		if custom:
			kwargs['custom'] = custom
			
		return cmds.nodePrest( presetName, **kwargs)
		
	def loadPreset(self, presetName):
		kwargs = {'load':True}
		return cmds.nodePrest( presetName, **kwargs)
		
	def deletePreset(self, presetName):
		kwargs = {'delete':True}
		return cmds.nodePrest( presetName, **kwargs)
		
	def listPresets(self):
		kwargs = {'list':True}
		return cmds.nodePrest( presetName, **kwargs)
			
	#--------------------------
	#	Info
	#--------------------------

	def type(self, **kwargs):
		"nodetype"		
		return self.nodeType(**kwargs)
			
	def exists(self, **kwargs):
		"objExists"
		return self.objExists(**kwargs)
		
	def isReadOnly(self):
		return (cmds.ls( self, ro=1) and True) or False
		
	def referenceFile(self):
		"""referenceQuery -file
		Return the reference file to which this object belongs.  None if object is not referenced"""
		try:
			return Reference( cmds.referenceQuery( self, f=1) )
		except:
			None
			
	def isReferenced(self):
		"""referenceQuery -isNodeReferenced
		Return True or False if the node is referenced"""	
		return cmds.referenceQuery( self, isNodeReferenced=1)

			
	def classification(self):
		'getClassification'
		return cmds.getClassification( self.type() )	
	
	#--------------------------
	#	Connections
	#--------------------------	
	
	def inputs(self, **kwargs):
		'listConnections -source 1 -destination 0'
		kwargs['source'] = True
		kwargs.pop('s', None )
		kwargs['destination'] = False
		kwargs.pop('d', None )
		return listConnections(self, **kwargs)
	
	def outputs(self, **kwargs):
		'listConnections -source 0 -destination 1'
		kwargs['source'] = False
		kwargs.pop('s', None )
		kwargs['destination'] = True
		kwargs.pop('d', None )
		
		return listConnections(self, **kwargs)							

	def sources(self, **kwargs):
		'listConnections -source 1 -destination 0'
		kwargs['source'] = True
		kwargs.pop('s', None )
		kwargs['destination'] = False
		kwargs.pop('d', None )
		return listConnections(self, **kwargs)
	
	def destinations(self, **kwargs):
		'listConnections -source 0 -destination 1'
		kwargs['source'] = False
		kwargs.pop('s', None )
		kwargs['destination'] = True
		kwargs.pop('d', None )
		
		return listConnections(self, **kwargs)	
		
	def shadingGroups(self):
		"""list any shading groups in the future of this object - works for shading nodes, transforms, and shapes """
		return self.future(type='shadingEngine')
		
		
	#--------------------------
	#	Attributes
	#--------------------------		
		
	def setAttr( self, attr, *args, **kwargs):
		return self.attr(attr).set( *args, **kwargs )
			
	def getAttr( self, attr, **kwargs ):
		return self.attr(attr).get( **kwargs )

	def addAttr( self, attr, **kwargs):		
		return self.attr(attr).add( **kwargs )
			
	def connectAttr( self, attr, *args, **kwargs ):
		return cmds.attr(attr).connect( *args, **kwargs )

	def disconnectAttr( self, source, destination=None, **kwargs ):
		if destination:
			return cmds.disconnectAttr( "%s.%s" % (self, source), destination, **kwargs )
		else:
			for destination in self.outputs( plugs=True ):
				cmds.disconnectAttr( "%s.%s" % (self, source), destination, **kwargs )
					


	_numPartReg = '([a-zA-Z|]+[a-zA-Z0-9_|]*[a-zA-Z]+)([0-9]+)$'
	def stripNum(self):
		"""Return the name of the node with trailing numbers stripped off. If no trailing numbers are found
		the name will be returned unchanged."""
		try:
			return re.match( Node._numPartReg, self).groups()[0]
		except:
			return unicode(self)
			
	def extractNum(self):
		"""Return the trailing numbers of the node name. If no trailing numbers are found
		an error will be raised."""
		
		try:
			return re.match( Node._numPartReg, self).groups()[1]
		except:
			raise "No trailing numbers to extract on object ", self

	def nextUniqueName(self):
		"""Increment the trailing number of the object until a unique name is found"""
		name = self.shortName().nextName()
		while name.exists():
			name = name.nextName()
		return name
				
	def nextName(self):
		"""Increment the trailing number of the object by 1"""
		try:
			groups = re.match( Node._numPartReg, self).groups()
			num = groups[1]
			formatStr = '%s%0' + unicode(len(num)) + 'd'			
			return self.__class__(formatStr % ( groups[0], (int(num) + 1) ))
		except:
			raise "could not find trailing numbers to increment"
			
	def prevName(self):
		"""Decrement the trailing number of the object by 1"""
		try:
			groups = re.match( Node._numPartReg, self).groups()
			num = groups[1]
			formatStr = '%s%0' + unicode(len(num)) + 'd'			
			return self.__class__(formatStr % ( groups[0], (int(num) - 1) ))
		except:
			raise "could not find trailing numbers to decrement"

'''
class MNode( object ):
	"""experimental"""
	
	def __init__(self, name):
		self.__dict__['name'] = name
		
	def __repr__(self):
		return "MNode('%s')" % self
	
	def __str__(self):
		return self.__dict__['name']
		
	#--------------------------
	#	Custom
	#--------------------------		
	
	"""
	def __getattr__(self, attr):
		if attr.startswith('_'):
			return Attribute( '%s.%s' % (self, attr[1:]) )
			
		return Attribute( '%s.%s' % (self, attr) )
	"""
	
	def __getattr__(self, attr):
		if attr.startswith('_'):
			attr = attr[1:]
		
		return getAttr( '%s.%s' % (self, attr) )
		
	def __setattr__(self, attr, val):
		if attr.startswith('_'):
			attr = attr[1:]
		
		setAttr( '%s.%s' % (self, attr), val )		
				
	def attr(self, attr):
		"""access to attribute of a node. returns an instance of the Attribute class for the 
		given attribute."""
		return Attribute( '%s.%s' % (self, attr) )


	#-------------------------------
	#	Name Info and Manipulation
	#-------------------------------
	
	def stripNamespace(self):
		"""Returns a new instance of the object with its namespace removed.  The calling instance is unaffected."""
		return self.__class__( '|'.join( map( lambda x: x.split(':')[-1], self.split('|') ) )  )

	def swapNamespace(self, prefix):
		"""Returns a new instance of the object with its current namespace replace with the provided one.  
		The calling instance is unaffected."""	
		return Node.addPrefix( self.stripNamespace(), prefix+':' )
			
	def namespaceList(self):
		"""Useful for cascading references.  Returns all of the namespaces of the calling object as a list""" 
		return self.split('|')[-1].split(':')[:-1]
			
	def namespace(self):
		"""Returns the namespace of the object with trailing colon included"""
		return ':'.join(self.namespaceList()) + ':'
		
	def addPrefix(self, prefix):
		'addPrefixToName'
		name = self
		leadingSlash = False
		if name.startswith('|'):
			name = name[1:]
			leadingSlash = True
		name = self.__class__( '|'.join( map( lambda x: prefix+x, name.split('|') ) ) )
		if leadingSlash:
			name = '|' + name
		return self.__class__( name )
				
	#--------------------------
	#	General
	#--------------------------

	def type(self, **kwargs):
		"nodetype"		
		return self.nodeType(**kwargs)
			
	def exists(self, **kwargs):
		"objExists"
		return self.objExists(**kwargs)
		
	def lock( self, **kwargs ):
		'lockNode -lock 1'
		kwargs['lock'] = True
		kwargs.pop('l',None)
		return cmds.lockNode( unicode(self), **kwargs)
		
	def unlock( self, **kwargs ):
		'lockNode -lock 0'
		kwargs['lock'] = False
		kwargs.pop('l',None)
		return cmds.lockNode( unicode(self), **kwargs)
		
	def listAttr( self, **kwargs):
		"listAttr"
		return cmds.listAttr(unicode(self), **kwargs)
		
	def rename(self, *args, **kwargs):
		"Rename the object. Returns the newly renamed object"
		newname =  cmds.rename( unicode(self),*args, **kwargs )
		self.name = newname
	
	def duplicate(self, **kwargs):
		"Duplicate the object. Returns the newly renamed object"
		return map(self.__class__, cmds.duplicate(self, **kwargs) )

	#--------------------------
	#	Info
	#--------------------------
	def isReadOnly(self):
		return (cmds.ls( self, ro=1) and True) or False
		
	def referenceFile(self):
		"Return the reference file to which this object belongs.  None if object is not referenced"
		try:
			return Reference( cmds.referenceQuery( self, f=1) )
		except:
			None
		
	#--------------------------
	#	Connections
	#--------------------------	
	
	def inputs(self, **kwargs):
		'listConnections -source 1 -destination 0'
		kwargs['source'] = True
		kwargs.pop('s', None )
		kwargs['destination'] = False
		kwargs.pop('d', None )
		return listConnections(self, **kwargs)
	
	def outputs(self, **kwargs):
		'listConnections -source 0 -destination 1'
		kwargs['source'] = False
		kwargs.pop('s', None )
		kwargs['destination'] = True
		kwargs.pop('d', None )
		
		return listConnections(self, **kwargs)							

	def shadingGroups(self):
		"""list any shading groups in the future of this object - works for shading nodes, transforms, and shapes """
		return self.future(type='shadingEngine')
		
		
	#--------------------------
	#	Attributes
	#--------------------------		
		
	def setAttr( self, attr, *args, **kwargs):
		return self.attr(attr).set( *args, **kwargs )
			
	def getAttr( self, attr, **kwargs ):
		return self.attr(attr).get( **kwargs )

	def addAttr( self, attr, **kwargs):		
		return self.attr(attr).add( **kwargs )
			
	def connectAttr( self, attr, *args, **kwargs ):
		return cmds.attr(attr).connect( *args, **kwargs )

	def disconnectAttr( self, source, destination=None, **kwargs ):
		if destination:
			return cmds.disconnectAttr( "%s.%s" % (self, source), destination, **kwargs )
		else:
			for destination in self.outputs( plugs=True ):
				cmds.disconnectAttr( "%s.%s" % (self, source), destination, **kwargs )
'''					
	
		
class Dag(Node):
	
	def __eq__(self, other):
		"""ensures that we compare longnames when checking for dag node equality"""
		try:
			return unicode(self.longName()) == unicode(Dag(other).longName())
		except TypeError:
			return unicode(self) == unicode(other)
			
	def __ne__(self, other):
		"""ensures that we compare longnames when checking for dag node equality"""
		try:
			return unicode(self.longName()) != unicode(Dag(other).longName())
		except TypeError:
			return unicode(self) != unicode(other)	
			
	#--------------------------
	#	Dag Path Info
	#--------------------------	
	def root(self):
		'rootOf'
		return Dag( '|' + self.longName()[1:].split('|')[0] )
	
	def firstParent(self):
		'firstParentOf'
		try:
			return Dag( '|'.join( self.longName().split('|')[:-1] ) )
		except TypeError:
			return Dag( '|'.join( self.split('|')[:-1] ) )
	
	def getParent(self, **kwargs):
		"""unlike the firstParent command which determines the parent via string formatting, this 
		command uses the listRelatives command"""
		
		kwargs['parent'] = True
		kwargs.pop('p',None)
		#if longNames:
		kwargs['fullPath'] = True
		kwargs.pop('p',None)
		
		try:
			res = cmds.listRelatives( self, **kwargs)[0]
		except TypeError:
			return None
			 
		res = Transform( res )
		if not longNames:
			return res.shortName()
		return res
					
	def getChildren(self, **kwargs ):
		kwargs['children'] = True
		kwargs.pop('c',None)

		return listRelatives( self, **kwargs)
		
	def getSiblings(self, **kwargs ):
		#pass
		try:
			return [ x for x in self.getParent().getChildren() if x != self]
		except:
			return []
				
	def listRelatives(self, **kwargs ):
		return listRelatives( self, **kwargs)
		
	def longName(self):
		'longNameOf'
		try:
			return self.__class__( cmds.ls( self, long=True )[0] )
		except TypeError, RuntimeError:
			raise TypeError, "cannot return longname for non-existant object: " + self
			
	def shortName( self ):
		'shortNameOf'
		try:
			return self.__class__( cmds.ls( self )[0] )
		except:
			return self

	def nodeName( self ):
		'basename'
		return self.__class__( self.split('|')[-1] )

		
	#--------------------------
	#	Dag Path Modification
	#--------------------------	
	
	def setParent( self, *args, **kwargs ):
		'parent'
		return self.__class__( cmds.parent( self, *args, **kwargs )[0] )
				
	def instance( self, **kwargs ):
		return self.__class__( cmds.instance(self, **kwargs) )

	#--------------------------
	#	Shading
	#--------------------------	

	def isDisplaced(self):
		"""Returns whether any of this object's shading groups have a displacement shader input"""
		for sg in self.shadingGroups():
			if len( sg._displacementShader.inputs() ):
				return True
		return False

	def setColor( self, color=None ):
		"""This command sets the dormant wireframe color of the specified objects to an integer
		representing one of the user defined colors, or, if set to None, to the default class color"""

		kwargs = {}
		if color:
			kwargs['userDefined'] = color
		cmds.color(self, **kwargs)
		
	def makeLive( self, state=True ):
		if not state:
			cmds.makeLive(none=True)
		else:
			cmds.makeLive(self)
			
class Transform(Dag):
	
	def __getattr__(self, attr):
		if attr.startswith('__') and attr.endswith('__'):
			return super(_BaseObj, self).__getattr__(attr)
						
		at = Attribute( '%s.%s' % (self, attr) )
		
		# if the attribute does not exist on this node try the shape node
		if not at.exists():
			try:
				childAttr = getattr( self.getShape(), attr)
				try:
					if childAttr.exists():
						return childAttr
				except AttributeError:
					return childAttr
			except (AttributeError,TypeError):
				pass
					
		return at
	
	def __setattr__(self, attr,val):
		if attr.startswith('_'):
			attr = attr[1:]
						
		at = Attribute( '%s.%s' % (self, attr) )
		
		# if the attribute does not exist on this node try the shape node
		if not at.exists():
			try:
				childAttr = getattr( self.getShape(), attr )
				try:
					if childAttr.exists():
						return childAttr.set(val)
				except AttributeError:
					return childAttr.set(val)
			except (AttributeError,TypeError):
				pass
					
		return at.set(val)
			
	"""	
	def move( self, *args, **kwargs ):
		return move( self, *args, **kwargs )
	def scale( self, *args, **kwargs ):
		return scale( self, *args, **kwargs )
	def rotate( self, *args, **kwargs ):
		return rotate( self, *args, **kwargs )
	def align( self, *args, **kwargs):
		args = (self,) + args
		cmds.align(self, *args, **kwargs)
	"""
	
	def hide(self):
		self.visibility.set(0)
		
	def show(self):
		self.visibility.set(1)
				
	def getShape( self, **kwargs ):
		kwargs['shapes'] = True
		try:
			return self.getChildren( **kwargs )[0]			
		except:
			pass
				
	def ungroup( self, **kwargs ):
		return cmds.ungroup( self, **kwargs )


	def setScale( self, val, **kwargs ):
		"""xform -scale"""
		kwargs['scale'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )
			
	def setRotation( self, val, **kwargs ):
		"""xform -rotation"""
		kwargs['rotation'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )

	def setTranslation( self, val, **kwargs ):
		"""xform -translation"""
		kwargs['translation'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )


	def setScalePivot( self, val, **kwargs ):
		"""xform -scalePivot"""
		kwargs['scalePivot'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )
		
	def setRotatePivot( self, val, **kwargs ):
		"""xform -rotatePivot"""
		kwargs['rotatePivot'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )
		
	def setPivots( self, val, **kwargs ):
		"""xform -pivots"""
		kwargs['pivots'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )

	def setRotateAxis( self, val, **kwargs ):
		"""xform -rotateAxis"""
		kwargs['rotateAxis'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )
		
								
	def setShearing( self, val, **kwargs ):
		"""xform -shear"""
		kwargs['shear'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )
								
	def setMatrix( self, val, **kwargs ):
		"""xform -scale"""
		if isinstance(val, Matrix):
			val = val.toList()
	
		kwargs['matrix'] = val
		kwargs.pop('q',None)
		kwargs.pop('query',None)
		cmds.xform( self, **kwargs )


	def getScale( self, **kwargs ):
		"""xform -scale"""
		kwargs['scale'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )
			
	def getRotation( self, **kwargs ):
		"""xform -rotation"""
		kwargs['rotation'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )

	def getTranslation( self, **kwargs ):
		"""xform -translation"""
		kwargs['translation'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )


	def getScalePivot( self, **kwargs ):
		"""xform -scalePivot"""
		kwargs['scalePivot'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )
		
	def getRotatePivot( self, **kwargs ):
		"""xform -rotatePivot"""
		kwargs['rotatePivot'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )
		
	def getPivots( self, **kwargs ):
		"""xform -pivots"""
		kwargs['pivots'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )

	def getRotateAxis( self, **kwargs ):
		"""xform -rotateAxis"""
		kwargs['rotateAxis'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )
		
								
	def getShearing( self, **kwargs ):
		"""xform -shear"""
		kwargs['shear'] = True
		kwargs['query'] = True
		return Vector( cmds.xform( self, **kwargs ) )
								
	def getMatrix( self, **kwargs ):
		"""xform -matrix"""
	
		kwargs['matrix'] = True
		kwargs['query'] = True
		return Matrix( cmds.xform( self, **kwargs ) )
			
	def getBoundingBox(self, invisible=False):
		"""xform -boundingBox and xform-boundingBoxInvisible
		
		returns a tuple with two MVecs: ( bbmin, bbmax )
		"""
		kwargs = {'query' : True }	
		if invisible:
			kwargs['boundingBoxInvisible'] = True
		else:
			kwargs['boundingBox'] = True
					
		res = cmds.xform( self, **kwargs )
		return ( Vector(res[:3]), Vector(res[3:]) )
	
	def getBoundingBoxMin(self, invisible=False):
		return self.getBoundingBox(invisible)[0]
		
	def getBoundingBoxMax(self, invisible=False):
		return self.getBoundingBox(invisible)[1]	
			
	def centerPivots(self):
		"""xform -centerPivots"""
		kwargs['centerPivots'] = True
		cmds.xform( self, **kwargs )
		
	def zeroTransformPivots(self):
		"""xform -zeroTransformPivots"""
		kwargs['centerPivots'] = True
		cmds.xform( self, **kwargs )		

	
#class Joint(Transform):
#	pass

		
class Camera_(Dag):
	def getFov(self):
		aperture = self.horizontalFilmAperture.get()
		fov = (0.5 * aperture) / (self.focalLength.get() * 0.03937)
		fov = 2.0 * atan (fov)
		fov = 57.29578 * fov
		return fov
		
	def setFov(self, fov):
		aperture = self.horizontalFilmAperture.get()
		focal = tan (0.00872665 * fov);
		focal = (0.5 * aperture) / (focal * 0.03937);
		self.focalLength.set(focal)
	
	def getFilmAspect(self):
		return self.horizontalFilmAperture.get()/ self.verticalFilmAperture.get()

	def applyBookmark(self, bookmark):
		kwargs = {}
		kwargs['camera'] = self
		kwargs['edit'] = True
		kwargs['setCamera'] = True
			
		cmds.cameraView( bookmark, **kwargs )
			
	def addBookmark(self, bookmark=None):
		kwargs = {}
		kwargs['camera'] = self
		kwargs['addBookmark'] = True
		if bookmark:
			kwargs['name'] = bookmark
			
		cmds.cameraView( **kwargs )
		
	def removeBookmark(self, bookmark):
		kwargs = {}
		kwargs['camera'] = self
		kwargs['removeBookmark'] = True
		kwargs['name'] = bookmark
			
		cmds.cameraView( **kwargs )
		
	def updateBookmark(self, bookmark):	
		kwargs = {}
		kwargs['camera'] = self
		kwargs['edit'] = True
		kwargs['setView'] = True
			
		cmds.cameraView( bookmark, **kwargs )
		
	def listBookmarks(self):
		return self.bookmarks.inputs()
	
	def dolly(self, **kwargs):
	 	return cmds.dolly(self, **kwargs)
	
	def roll(self, **kwargs):
	 	return cmds.roll(self, **kwargs)

	def orbit(self, **kwargs):
	 	return cmds.orbit(self, **kwargs)

	def track(self, **kwargs):
	 	return cmds.track(self, **kwargs)

	def tumble(self, **kwargs):
	 	return cmds.tumble(self, **kwargs)
	
	
class Constraint_(Dag):
	def setWeight( self, weight, *targetObjects ):
		inFunc = getattr( cmds, self.type() )
		if not targetObjects:
			targetObjects = self.getTargetList() 
		
		constraintObj = self.constraintParentInverseMatrix.inputs()[0]	
		targetObjects = list(targetObjects) + [constraintObj]
		return inFunc(  *targetObjects, **{'edit':True, 'weight':weight} )
		
	def getWeight( self, *targetObjects ):
		inFunc = getattr( cmds, self.type() )
		if not targetObjects:
			targetObjects = self.getTargetList() 
		
		constraintObj = self.constraintParentInverseMatrix.inputs()[0]	
		targetObjects = list(targetObjects) + [constraintObj]
		return inFunc(  *targetObjects, **{'query':True, 'weight':True} )
		
class Poly(Dag):
	"""
	Cycle through faces and select those that point up in world space
	
	>>> s = PyNode('pSphere1')
	>>> for face in s.faces:
	>>> 	if face.normal.objectToWorld(s).y > 0:
	>>> 		print face
	>>> 		select( face , add=1)
	
	"""
	def _getFaceArray(self):
		return FaceArray( self + '.f' )	
	f = property(_getFaceArray)
	faces = property(_getFaceArray)
	
	def _getEdgeArray(self):
		return EdgeArray( self + '.e' )	
	e = property(_getEdgeArray)
	edges = property(_getEdgeArray)
	
	def _getVertexArray(self):
		return VertexArray( self + '.vtx' )	
	vtx = property(_getVertexArray)
	verts = property(_getVertexArray)
			
	def __getattr__(self, attr):
		if attr.startswith('__') and attr.endswith('__'):
			return super(_BaseObj, self).__getattr__(attr)
						
		at = Attribute( '%s.%s' % (self, attr) )
		
		# if the attribute does not exist on this node try the history
		if not at.exists():
			try:
				childAttr = getattr( self.inMesh.inputs()[0], attr )
			
				try:
					if childAttr.exists():
						return childAttr
				except AttributeError:
					return childAttr
			
			except IndexError:
				pass
			"""
			try:	
				return getattr( self.inMesh.inputs()[0], attr)
			except IndexError:
				raise AttributeError, "Attribute does not exist: %s" % at
			"""
		return at

	def __setattr__(self, attr, val):
		if attr.startswith('_'):
			attr = attr[1:]
						
		at = Attribute( '%s.%s' % (self, attr) )
		
		# if the attribute does not exist on this node try the history
		if not at.exists():
			try:
				childAttr = getattr( self.inMesh.inputs()[0], attr )
			
				try:
					if childAttr.exists():
						return childAttr.set(val)
				except AttributeError:
					return childAttr.set(val)
			
			except IndexError:
				pass
			"""
			try:	
				return getattr( self.inMesh.inputs()[0], attr)
			except IndexError:
				raise AttributeError, "Attribute does not exist: %s" % at
			"""
		return at.set(val)
					
	def polyEvaluate(self, **kwargs):
		return cmds.polyEvaluate(self, **kwargs)
	
	def numVerts(self):
		return cmds.polyEvaluate(self, vertex=True)
		
	def numEdges(self):
		return cmds.polyEvaluate(self, edge=True)

	def numFaces(self):
		return cmds.polyEvaluate(self, face=True)
		
	def numUVs(self):
		return cmds.polyEvaluate(self, uvcoord=True)
		
	def numTris(self):
		return cmds.polyEvaluate(self, triangle=True)	

	def numSelectedVerts(self):
		return cmds.polyEvaluate(self, vertex=True)
		
	def numSelectedEdges(self):
		return cmds.polyEvaluate(self, edge=True)

	def numSelectedFaces(self):
		return cmds.polyEvaluate(self, face=True)
		
	def numSelectedUVs(self):
		return cmds.polyEvaluate(self, uvcoord=True)
		
	def numSelectedTris(self):
		return cmds.polyEvaluate(self, triangle=True)	
		
	def area(self):
		return cmds.polyEvaluate(self, area=True)
		
	def worldArea(self):
		return cmds.polyEvaluate(self, worldArea=True)
	
	'''
	def _listComponent( self, compType, num ):
		for i in range(0, num):
			 yield Attribute( '%s.vtx[%s]' % (self, i) )
	
	def verts(self):
		return self._listComponent( 'vtx', self.numVerts() )
	'''
						
class Nurbs(Dag):
	
	pass
		
class Curve(Dag):
	
	pass

class Subdiv(Dag):
	def getTweakedVerts(self, **kwargs):
		return cmds.querySubdiv( action=1, **kwargs )
		
	def getSharpenedVerts(self, **kwargs):
		return cmds.querySubdiv( action=2, **kwargs )
		
	def getSharpenedEdges(self, **kwargs):
		return cmds.querySubdiv( action=3, **kwargs )
		
	def getEdges(self, **kwargs):
		return cmds.querySubdiv( action=4, **kwargs )
				
	def cleanTopology(self):
		cmds.subdCleanTopology(self)
	
class Particle_(Dag):
	
	class PointArray(object):
		def __init__(self, particle):
			self._particle = particle

		def __getitem__(self, item):
			return Particle.Point( self._particle, item )
		
	class Point(object):
		def __init__(self, particle, order):
			self._particle = particle
			self._order = order
			
		def __getattr__(self, attr):
			return cmds.particle( self._particle, q=1, attribute=attr, order=self._order)
			
	
	def __getattr__(self, attr):
		if attr.startswith('pt'):
			return Particle.PointArray( self )	
		
		if attr.startswith('_'):
			return Attribute( '%s.%s' % (self, attr[1:]) )
			
		return Attribute( '%s.%s' % (self, attr) )
	
	def num(self):
		return cmds.particle( self, q=1,count=1)
	
class Set(Node):
	"""
	this is currently a work in progress.  my goal is to create a class for doing set operations in maya that is
	compatiable with python's powerful built-in set class.  
	
	each operand has its own method equivalent. 
	
	these will return the results of the operation as python sets containing lists of pymel node classes::
	
		s&t 	s.intersection(t)
		s|t		s.union(t)
		s^t		s.symmetric_difference(t)
		s-t		s.difference(t)
	
	the following will alter the contents of the maya set::
		
		s&=t 	s.intersection_update(t)
		s|=t	s.update(t)
		s^=t	s.symmetric_difference_update(t)
		s-=t	s.difference_update(t)		
	
	create some sets
	
		>>> sphere = polySphere()
		>>> cube = polyCube()
		>>> s = sets( cube )
		>>> s.update( ls( type='camera') )
		>>> t = sets( sphere )
		>>> t.add( 'perspShape' )

		>>> print s|t  # union

		>>> u = sets( s&t ) # intersection
		>>> print u.elements(), s.elements()
		>>> if u < s: print "%s is a sub-set of %s" % (u, s)
		
	place a set inside another, take1
	
		>>> # like python's built-in set, the add command expects a single element
		>>> s.add( t )

	place a set inside another, take2
	
		>>> # like python's built-in set, the update command expects a set or a list
		>>> t.update([u])

		>>> # put the sets back where they were
		>>> s.remove(t)
		>>> t.remove(u)

	now put the **contents** of a set into another set
	
		>>> t.update(u)

	mixed operation between pymel.Set and built-in set
		
		>>> v = set(['polyCube3', 'pSphere3'])
		>>> print s.intersection(v)
		>>> print v.intersection(s)  # not supported yet
		>>> u.clear()

		>>> delete( s )
		>>> delete( t )
		>>> delete( u )
	"""
			
	def _elements(self):
		""" used internally to get a list of elements without casting to node classes"""
		return sets( self, q=True)
	#-----------------------
	# Maya Methods
	#-----------------------
	def elements(self):
		return set( map( PyNode, self._elements() ) )

	def subtract(self, set2):
		return sets( self, subtract=set2 )
	
	def flatten(self):
		return sets( flatten=self )
	
	#-----------------------
	# Python Set Methods
	#-----------------------
	def __and__(self, s):
		return self.intersection(s)

	def __iand__(self, s):
		return self.intersection_update(s)
					
	def __contains__(self, element):
		return element in self._elements()

	#def __eq__(self, s):
	#	return s == self._elements()

	#def __ne__(self, s):
	#	return s != self._elements()
			
	def __or__(self, s):
		return self.union(s)

	def __ior__(self, s):
		return self.update(s)
									
	def __len__(self, s):
		return len(self._elements())

	def __lt__(self, s):
		return self.issubset(s)

	def __gt__(self, s):
		return self.issuperset(s)
					
	def __sub__(self, s):
		return self.difference(s)

	def __isub__(self, s):
		return self.difference_update(s)						

	def __xor__(self, s):
		return self.symmetric_difference(s)
		
	def add(self, element):
		return sets( [element], add=self )
	
	def clear(self):
		return sets( clear=self )
	
	def copy(self ):
		return sets( copy=self )
	
	def difference(self, elements):
		if isinstance(elements,basestring):
			elements = cmds.sets( elements, q=True)
		return list(set(self.elements()).difference(elements))
		
		'''
		if isinstance(s, Set) or isinstance(s, str):
			return sets( s, subtract=self )
		
		s = sets( s )
		res = sets( s, subtract=self )
		cmds.delete(s)
		return res'''
	
	def difference_update(self, elements ):
		return sets( elements, remove=self)
	
	def discard( self, element ):
		try:
			return self.remove(element)
		except TypeError:
			pass

	def intersection(self, elements):
		if isinstance(elements,basestring):
			elements = cmds.sets( elements, q=True)
		return set(self.elements()).intersection(elements)
	
	def intersection_update(self, elements):
		self.clear()
		sets( self.intersections(elements), add=self )
			
	def issubset(self, s):
		return sets( self, isMember=s)

	def issuperset(self, s):
		return sets( s, isMember=self)
			
	def remove( self, element ):
		return sets( [element], remove=self)

	def symmetric_difference(self, elements):
		if isinstance(elements,basestring):
			elements = cmds.sets( elements, q=True)
		return set(self.elements()).symmetric_difference(elements)
			
	def union( self, elements ):
		if isinstance(elements,basestring):
			elements = cmds.sets( elements, q=True)
		return set(self.elements()).union(elements)
	
	def update( self, s ):		
		sets( s, forceElement=self )
		
		#if isinstance(s, str):
		#	items = Set(  )
			
		#items = self.union(items)



#-----------------------------------------------
#  Commands for Creating pymel Objects
#-----------------------------------------------
def PyNode(strObj, type=None):
	"""Casts a string to a pymel class. Use this function if you are unsure which class is the right one to use
	for your object."""
	

	try:
		if '.' in strObj:
			return Attribute(strObj)
	except TypeError:
		raise 'PyNode: expected a string or unicode object, got %s' % type(strObj)
		
	#if '|' in strObj:
	#	return Dag(strObj)
	
	#if cmds.ls( strObj, dag=True):
	#		return Dag(strObj)
	try:	
		return PyDag(strObj,type)
	except: pass
	
	if cmds.ls( strObj, sets=True):
		return Set(strObj)
	
	return Node(strObj)
	
			
#-----------------------------------------------
#  Pymel Internals
#-----------------------------------------------
			
	
def _mapClass( strObjs ):
	dags = cmds.ls( transforms = 1, shapes=1 )
	sets = cmds.ls( sets = 1 )
	
	def chooser(i):
		if '.' in i:
			return Attribute(i)
		if i in dags:
			return Dag(i)
		if i in sets:
			return Set(i)
		return Node(i)
		
	return map( chooser, strObjs )

returnMap = {
		'transform':	Transform,
		'mesh':			Poly,
		'nurbsSurface':	Nurbs,
		'nurbsCurve':	Curve,

}
#returnMap.update( creationReturnMap )
	
def PyDag( strObj, type=None ):
	"""Casts a string to a pymel dag class. Use this function if you are unsure which dag class is the right one to use
	for your object."""
	#print returnMap
	if type is None:
		type = cmds.nodeType( strObj )
		
	try: return returnMap[ type ](strObj)
	except KeyError:
		if cmds.ls( strObj, dag=True):
			return Dag(strObj)
		else:
			raise TypeError
				


"""
import os,sys,pydoc, pymel
reload(pymel)
os.chdir( sys.path[1] + "/docs" )
print "writing out to", sys.path[1]
pydoc.writedoc(pymel)


import os,sys,pydoc, pymel, pymel.vector, pymel.mel2py, pymel.ui
os.chdir( "/Volumes/luma/_globalSoft/python/published/pymel/docs" )
reload(pymel)
reload(pymel.vector)
reload(pymel.mel2py)
#reload(pymel.ui)
pydoc.writedoc(pymel)
pydoc.writedoc(pymel.vector)
pydoc.writedoc(pymel.mel2py)
#pydoc.writedoc(pymel.ui)


def cleanup( topdir ):
	topdir = path.path(topdir)
	for dir in [topdir] + topdir.dirs():
		print "scanning", dir
		if dir.name == '_backup':
			print "deleteing dir", dir
			dir.rmtree(ignore_errors=1)
		else:
			for f in dir.files():
				if f.name.startswith('.') or f.ext in ['.pyc', '.tmproj']:
					print "deleting", f
					f.remove()

			
cleanup( '/Volumes/luma/_globalSoft/python/published/_release/pymel')


# test
import pymel.examples.texturePathUI_pymel

"""

	
