
"""
The io module contains functions relating to files and references.

In particular, the io module contains the functionality of maya.cmds.file. The file command should not be imported into
the default namespace because it conflicts with python's builtin file class. Since the file command has so many flags, 
I decided to kill two birds with one stone: by breaking the file command down into multiple functions -- one for each 
primary flag -- the resulting functions are more readable and allow the file command's functionality to be used directly
within the pymel namespace.   

for example, instead of this:
	
	>>> expFile = cmds.file( exportAll=1, preserveReferences=1 )
	
you can do this:

	>>> expFile = exportAll( preserveReferences=1)
	
some of the new commands were changed slightly from their flag name to avoid name clashes and to add to readability:

	>>> importFile( expFile )
	>>> createReference( expFile )

also note that the 'type' flag is set automatically for you when your path includes a '.mb' or '.ma' extension.
"""

try:
	import maya.cmds as cmds
	import maya.OpenMaya as OpenMaya
except ImportError: pass

import pymel.util
try:
    from luma.filepath import filepath as Filepath
    pathClass = Filepath
except ImportError:
    pathClass = pymel.util.path
    
import sys

#from pymel.core.node import pymel.core.node.Matrix
#import pymel.core
import pymel.core.node

def _getTypeFromExtension( path ):
	return {
		'.ma' : 'mayaAscii',
		'.mb' :	'mayaBinary'
	}[Path(path).ext]


def feof( fileid ):
    """Reproduces the behavior of the mel command of the same name. if writing pymel scripts from scratch, 
    you should use a more pythonic construct for looping through files:
    
    >>> f = open('myfile.txt')
    >>> for line in f:
    >>>     print line
    
    This command is provided for python scripts generated by py2mel"""
    
    os = fileid.tell()
    f.seek(0,2) # goto end of file
    end = fileid.tell() #get final position
    fileid.seek(pos)
    return pos == end

from pymel.tools.scanf import fscanf


def sceneName():
    #return pymel.core.io.Path(cmds.file( q=1, sn=1))
    return Path( OpenMaya.MFileIO.currentFile() )	

def listNamespaces():
	"""Returns a list of the namespaces of referenced files.
	REMOVE In Favor of listReferences('dict') ?""" 
	try:
		return [ cmds.file( x, q=1, namespace=1) for x in cmds.file( q=1, reference=1)  ]
	except:
		return []





def listReferences(type='list'):
	"""file -q -reference
	By default returns a list of reference files as FileReference classes. The optional type argument can be passed a 'dict'
	(or dict object) to return the references as a dictionary with namespaces as keys and References as values.
	
	Untested: multiple references with no namespace...
	"""
	
	# dict
	if type in ['dict', dict]:
		res = {}
		try:
			for x in cmds.file( q=1, reference=1):
				res[cmds.file( x, q=1, namespace=1)] = FileReference(x)
		except: pass
		return res
	
	# list
	return map( FileReference,cmds.file( q=1, reference=1) )

def getReferences(reference=None, recursive=False):
	res = {}	
	if reference is None:
		try:
			for x in cmds.file( q=1, reference=1):
				ref = FileReference(x)
				res[cmds.file( x, q=1, namespace=1)] = ref
				if recursive:
					res.update( ref.subReferences() )
		except: pass
	else:
		try:
			for x in cmds.file( self, q=1, reference=1):
				res[cmds.file( x, q=1, namespace=1)] = FileReference(x)
		except: pass
	return res	
	
def createReference( *args, **kwargs ):
	"""file -reference"""
	kwargs['reference'] = True
	return FileReference(cmds.file(*args, **kwargs))

def loadReference( file, refNode, **kwargs ):
	"""file -loadReference"""
	kwargs['loadReference'] = refNode
	return FileReference(cmds.file(file, **kwargs))
		
def exportAll( *args, **kwargs ):
	"""file -exportAll"""
	kwargs['exportAll'] = True
	try:
		kwargs['type'] = _getTypeFromExtension(args[0])
	except KeyError: pass
	
	return Path(cmds.file(*args, **kwargs))

def exportAnim( *args, **kwargs ):
	"""file -exportAnim"""
	kwargs['exportAnim'] = True
	return Path(cmds.file(*args, **kwargs))

def exportAnimFromReference( *args, **kwargs ):
	"""file -exportAnimFromReference"""
	kwargs['exportAnimFromReference'] = True
	return Path(cmds.file(*args, **kwargs))

def exportAsReference( *args, **kwargs ):
	"""file -exportAsReference"""
	kwargs['exportAsReference'] = True
	try:
		kwargs['type'] = _getTypeFromExtension(args[0])
	except KeyError: pass
	return FileReference(cmds.file(*args, **kwargs))

def exportSelected( *args, **kwargs ):
	"""file -exportSelected"""
	kwargs['exportSelected'] = True
	try:
		kwargs['type'] = _getTypeFromExtension(args[0])
	except KeyError: pass
	return Path(cmds.file(*args, **kwargs))
	
def exportSelectedAnim( *args, **kwargs ):
	"""file -exportSelectedAnim"""
	kwargs['exportSelectedAnim'] = True
	return Path(cmds.file(*args, **kwargs))
	
def exportSelectedAnimFromReference( *args, **kwargs ):
	"""file -exportSelectedAnimFromReference"""
	kwargs['exportSelectedAnimFromReference'] = True
	return Path(cmds.file(*args, **kwargs))

def importFile( *args, **kwargs ):
	"""file -import"""
	kwargs['import'] = True
	return Path(cmds.file(*args, **kwargs))

def newFile( *args, **kwargs ):
	"""file -newFile"""
	kwargs['newFile'] = True
	return Path(cmds.file(*args, **kwargs))

def openFile( *args, **kwargs ):
	"""file -open"""
	kwargs['open'] = True
	return Path(cmds.file(*args, **kwargs))	

def renameFile( *args, **kwargs ):
	"""file -rename"""
	kwargs['rename'] = True
	return Path(cmds.file(*args, **kwargs))
	
def saveAs(filepath, **kwargs):
	cmds.file( rename=filepath )
	kwargs['save']=True
	try:
		kwargs['type'] = _getTypeFromExtension(filepath)
	except KeyError: pass
	return Path(cmds.file(**kwargs) )


#-----------------------------------------------
#  File Classes
#-----------------------------------------------
    
class Path(pathClass):
    """A basic Maya file class. it gets most of its power from the path class written by Jason Orendorff.
    see path.py for more documentation."""
    def __repr__(self):
        return "%s('%s')" % (self.__class__.__name__, self)
    def writable(self):
        return cmds.file( self, q=1, writable=1 )
    def type(self):
        return cmds.file( self, q=1, type=1 )
        
class FileReference(Path):
    """A class for manipulating references which inherits Path and path.  you can create an 
    instance by supplying the path to a reference file, its namespace, or its reference node to the 
    appropriate keyword. The namespace and reference node of the reference can be retreived via 
    the namespace and refNode properties. The namespace property can also be used to change the namespace
    of the reference. 
    
    Use listRefences command to return a list of references as instances of the FileReference class.
    
    It is important to note that instances of this class will have their copy number stripped off
    and stored in an internal variable upon creation.  This is to maintain compatibility with the numerous methods
    inherited from the path class which requires a real file path. When calling built-in methods of FileReference, 
    the path will automatically be suffixed with the copy number before being passed to maya commands, thus ensuring 
    the proper results in maya as well. 
     """
    
    def __new__(cls, path=None, namespace=None, refnode=None):
        def create(path):
            def splitCopyNumber(path):
                """Return a tuple with the path and the copy number. Second element will be None if no copy number"""
                buf = path.split('{')
                try:
                    return ( buf[0], int(buf[1][:-1]) )
                except:
                    return (path, None)
                    
            path, copyNumber = splitCopyNumber(path)
            self = Path.__new__(cls, path)
            self._copyNumber = copyNumber
            return self
            
        if path:
            return create(path)
        if namespace:
            for path in map( FileReference, cmds.file( q=1, reference=1) ):
                 if path.namespace == namespace:
                    return create(path)
            raise ValueError, "Namespace '%s' does not match any found in scene" % namespace
        if refnode:
            path = cmds.referenceQuery( refnode, filename=1 )
            return create(path)
        raise ValueError, "Must supply at least one argument"    

    def subReferences(self):
        namespace = self.namespace + ':'
        res = {}
        try:
            for x in cmds.file( self, q=1, reference=1):
                res[namespace + cmds.file( x, q=1, namespace=1)] = pymel.FileReference(x)
        except: pass
        return res    
        
        
    def namespaceExists(self):
        return cmds.namespace(ex=self.namespace)
        
    def withCopyNumber(self):
        """return this path with the copy number at the end"""
        if self._copyNumber is not None:
            return Path( '%s{%d}' % (self, self._copyNumber) )
        return self
            
    def importContents(self):
        """file -importReference """
        return cmds.file( self.withCopyNumber(), importReference=1 )
    def    remove(self):
        """file -removeReference """
        return cmds.file( self.withCopyNumber(), removeReference=1 )
    def    unload(self):
        """file -unloadReference """
        return cmds.file( self.withCopyNumber(), unloadReference=1 )    
    def    clean(self):
        """file -cleanReference """
        return cmds.file( self.withCopyNumber(), cleanReference=1 )
    def    lock(self):
        """file -lockReference """
        return cmds.file( self.withCopyNumber(), lockReference=1 )
    
    def isDeferred(self):
        """file -q -deferReference """
        return cmds.file( self.withCopyNumber(), q=1, deferReference=1 )
    def isLoaded(self):
        return not cmds.file( self.withCopyNumber(), q=1, deferReference=1 )
    
    def nodes(self):
        """referenceQuery -nodes """
        return map( pymel.core.node.Matrix, cmds.referenceQuery( self.withCopyNumber(), nodes=1 ) )
    def copyNumberList(self):
        """returns a list of all the copy numbers of this file"""
        return cmds.file( self, q=1, copyNumberList=1 )
    def selectAll(self):
        """file -selectAll"""
        return cmds.file( self.withCopyNumber(), selectAll=1 )
            
    def _getNamespace(self):
        return cmds.file( self.withCopyNumber(), q=1, ns=1)
    def _setNamespace(self, namespace):
        return cmds.file( self.withCopyNumber(), e=1, ns=namespace)    
    namespace = property( _getNamespace, _setNamespace )

    def _getRefNode(self):
        return node.DependNode(cmds.referenceQuery( self.withCopyNumber(), referenceNode=1 ))    
    refNode = pymel.util.cacheProperty( _getRefNode, '_refNode')

